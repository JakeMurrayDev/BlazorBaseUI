@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject ILogger<AvatarImage> Logger

<RenderElement TState="AvatarRootState"
               Tag="img"
               State="state"
               Enabled="imageLoadingStatus == ImageLoadingStatus.Loaded"
               Render="Render"
               ClassValue="ClassValue"
               StyleValue="StyleValue"
               ChildContent="ChildContent"
               @attributes="AdditionalAttributes"
               @ref="renderElementReference" />

@code {
    private readonly Lazy<Task<IJSObjectReference>> moduleTask;

    private ImageLoadingStatus imageLoadingStatus = ImageLoadingStatus.Idle;
    private Func<Task> cachedLoadImageCallback = default!;
    private AvatarRootState state = new(ImageLoadingStatus.Idle);
    private string? previousSrc;
    private bool hasRendered;
    private RenderElement<AvatarRootState>? renderElementReference;

    [CascadingParameter]
    private AvatarRootContext? Context { get; set; }

    private string? Src => AttributeUtilities.GetAttributeStringValue(AdditionalAttributes, "src");

    private string? ReferrerPolicy => AttributeUtilities.GetAttributeStringValue(AdditionalAttributes, "referrerpolicy");

    private string? CrossOrigin => AttributeUtilities.GetAttributeStringValue(AdditionalAttributes, "crossorigin");

    /// <summary>
    /// Gets or sets the callback fired when the loading status changes.
    /// </summary>
    [Parameter]
    public EventCallback<ImageLoadingStatus> OnLoadingStatusChange { get; set; }

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// Accepts a function that returns the element to render.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<AvatarRootState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets the CSS class function based on the component state.
    /// </summary>
    [Parameter]
    public Func<AvatarRootState, string?>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets the inline style function based on the component state.
    /// </summary>
    [Parameter]
    public Func<AvatarRootState, string?>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    public AvatarImage()
    {
        moduleTask = new Lazy<Task<IJSObjectReference>>(() =>
            JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "./_content/BlazorBaseUI/blazor-baseui-avatar-image.js").AsTask());
    }

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        if (Context is null)
        {
            throw new InvalidOperationException(
                "AvatarRootContext is missing. Avatar parts must be placed within <AvatarRoot>.");
        }

        cachedLoadImageCallback = async () =>
        {
            try
            {
                await LoadImageAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error loading image in {Component}", nameof(AvatarImage));
            }
        };
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        if (state.ImageLoadingStatus != imageLoadingStatus)
        {
            state = new AvatarRootState(imageLoadingStatus);
        }

        if (hasRendered && Src != previousSrc)
        {
            previousSrc = Src;
            _ = InvokeAsync(cachedLoadImageCallback);
        }
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            previousSrc = Src;

            try
            {
                await LoadImageAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error loading image in {Component}", nameof(AvatarImage));
            }
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (moduleTask.IsValueCreated)
        {
            try
            {
                var module = await moduleTask.Value;
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }
    }

    private async Task LoadImageAsync()
    {
        try
        {
            imageLoadingStatus = ImageLoadingStatus.Loading;
            state = new AvatarRootState(imageLoadingStatus);
            await OnLoadingStatusChange.InvokeAsync(imageLoadingStatus);
            Context!.SetImageLoadingStatus(imageLoadingStatus);

            var module = await moduleTask.Value;
            var status = await module.InvokeAsync<string>("loadImage", Src, ReferrerPolicy, CrossOrigin);

            imageLoadingStatus = status switch
            {
                "loaded" => ImageLoadingStatus.Loaded,
                "error" => ImageLoadingStatus.Error,
                _ => ImageLoadingStatus.Idle
            };

            state = new AvatarRootState(imageLoadingStatus);
            await OnLoadingStatusChange.InvokeAsync(imageLoadingStatus);
            Context!.SetImageLoadingStatus(imageLoadingStatus);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }
}
