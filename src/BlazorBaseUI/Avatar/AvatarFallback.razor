@namespace BlazorBaseUI.Avatar
@using System.Diagnostics.CodeAnalysis
@implements IDisposable

@if (Context?.ImageLoadingStatus != ImageLoadingStatus.Loaded && delayPassed)
{
    <span @attributes="AdditionalAttributes"
          class="@ResolvedClass"
          style="@ResolvedStyle"
          @ref="Element">
        @ChildContent
    </span>
}

@code {
    private CancellationTokenSource? delayCts;
    private bool delayPassed;

    [CascadingParameter]
    private AvatarContext? Context { get; set; }

    [Parameter]
    public int? Delay { get; set; }

    [Parameter]
    public ClassValue<ImageLoadingStatus?> ClassValue { get; set; }

    [Parameter]
    public StyleValue<ImageLoadingStatus?> StyleValue { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    [DisallowNull]
    public ElementReference? Element { get; protected set; }

    private string? ResolvedClass => AttributeUtilities.CombineClassNames(
        AdditionalAttributes,
        ClassValue.Resolve(Context?.ImageLoadingStatus));

    private string? ResolvedStyle => AttributeUtilities.CombineStyles(
        AdditionalAttributes,
        StyleValue.Resolve(Context?.ImageLoadingStatus));

    protected override void OnInitialized()
    {
        if (Context is null)
        {
            throw new InvalidOperationException(
                "Base UI: AvatarRootContext is missing. Avatar parts must be placed within <AvatarRoot>.");
        }

        delayPassed = Delay is null;
    }

    protected override void OnParametersSet()
    {
        if (Delay is not null && !delayPassed)
        {
            _ = StartDelayAsync();
        }
    }

    private async Task StartDelayAsync()
    {
        delayCts?.Cancel();
        delayCts = new CancellationTokenSource();

        try
        {
            await Task.Delay(Delay!.Value, delayCts.Token);
            delayPassed = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (TaskCanceledException)
        {
        }
    }

    public void Dispose()
    {
        delayCts?.Cancel();
        delayCts?.Dispose();
    }
}