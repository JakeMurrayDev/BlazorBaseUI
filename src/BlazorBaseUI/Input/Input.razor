@using System.Linq.Expressions
@using BlazorBaseUI.Field

@implements IReferencableComponent

<FieldControl TValue="string"
              Value="Value"
              ValueChanged="ValueChanged"
              ValueExpression="ValueExpression"
              DefaultValue="DefaultValue"
              DisplayName="DisplayName"
              Name="Name"
              Disabled="Disabled"
              Render="wrappedRender"
              ClassValue="wrappedClassValue"
              StyleValue="wrappedStyleValue"
              @attributes="AdditionalAttributes"
              @ref="fieldControlRef" />

@code {
    private FieldControl<string>? fieldControlRef;
    private RenderFragment<RenderProps<FieldRootState>>? wrappedRender;
    private Func<FieldRootState, string>? wrappedClassValue;
    private Func<FieldRootState, string>? wrappedStyleValue;

    /// <summary>
    /// Gets or sets the controlled value of the input.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Gets or sets the callback fired when the input value changes.
    /// </summary>
    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the expression that identifies the bound value.
    /// </summary>
    [Parameter]
    public Expression<Func<string>>? ValueExpression { get; set; }

    /// <summary>
    /// Gets or sets the default value for the uncontrolled input.
    /// </summary>
    [Parameter]
    public string? DefaultValue { get; set; }

    /// <summary>
    /// Gets or sets the display name used for validation messages.
    /// </summary>
    [Parameter]
    public string? DisplayName { get; set; }

    /// <summary>
    /// Gets or sets the name of the input element.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Determines whether the input is disabled.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// Accepts a function that returns the element to render.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<InputState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets the CSS class function based on the component state.
    /// </summary>
    [Parameter]
    public Func<InputState, string>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets the inline style function based on the component state.
    /// </summary>
    [Parameter]
    public Func<InputState, string>? StyleValue { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => fieldControlRef?.Element;

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        wrappedRender = Render is not null
            ? fieldProps => Render(new RenderProps<InputState>(
                fieldProps.Attributes,
                InputState.FromFieldRootState(fieldProps.State),
                fieldProps.ChildContent,
                fieldProps.ElementReferenceCallback))
            : null;

        wrappedClassValue = ClassValue is not null
            ? state => ClassValue(InputState.FromFieldRootState(state))
            : null;

        wrappedStyleValue = StyleValue is not null
            ? state => StyleValue(InputState.FromFieldRootState(state))
            : null;
    }
}
