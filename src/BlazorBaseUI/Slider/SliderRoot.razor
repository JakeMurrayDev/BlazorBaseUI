@using Microsoft.JSInterop
@using BlazorBaseUI.Field
@using BlazorBaseUI.Form
@using BlazorBaseUI.Utilities.LabelableProvider
@implements IFieldStateSubscriber
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<CascadingValue Value="context" IsFixed="true">
    <RenderElement TState="SliderRootState"
                   Tag="div"
                   State="state"
                   Render="Render"
                   ClassValue="ClassValue"
                   StyleValue="StyleValue"
                   ComponentAttributes="componentAttributes"
                   ChildContent="ChildContent"
                   @attributes="AdditionalAttributes"
                   @ref="renderElementReference" />
</CascadingValue>

@code {
    private const string JsModulePath = "./_content/BlazorBaseUI/blazor-baseui-slider.js";
    private const double Epsilon = 1e-10;

    private readonly Dictionary<int, ThumbMetadata> thumbRegistry = [];

    private Lazy<Task<IJSObjectReference>>? moduleTask;
    private int realtimeSubscriberCount;
    private SliderRootContext context = null!;
    private SliderRootState state;
    private bool hasRendered;
    private double[] currentValues = null!;
    private double[] previousValues = null!;
    private int activeThumbIndex = -1;
    private int lastUsedThumbIndex = -1;
    private bool dragging;
    private string? defaultId;
    private ElementReference? controlElement;
    private ElementReference? indicatorElement;
    private RenderElement<SliderRootState>? renderElementReference;
    private Dictionary<string, object> componentAttributes = new();

    private Lazy<Task<IJSObjectReference>> ModuleTask => moduleTask ??= new Lazy<Task<IJSObjectReference>>(() =>
        JSRuntime.InvokeAsync<IJSObjectReference>("import", JsModulePath).AsTask());

    [CascadingParameter]
    private FieldRootContext? FieldContext { get; set; }

    [CascadingParameter]
    private FormContext? FormContext { get; set; }

    [CascadingParameter]
    private LabelableContext? LabelableContext { get; set; }

    /// <summary>
    /// Gets or sets the controlled value of the slider.
    /// For ranged sliders, use <see cref="Values"/> instead.
    /// </summary>
    [Parameter]
    public double? Value { get; set; }

    /// <summary>
    /// Gets or sets the controlled values for a range slider.
    /// Provide an array with two values for a ranged slider.
    /// </summary>
    [Parameter]
    public double[]? Values { get; set; }

    /// <summary>
    /// Gets or sets the uncontrolled default value of the slider when it is initially rendered.
    /// To render a controlled slider, use <see cref="Value"/> instead.
    /// </summary>
    [Parameter]
    public double? DefaultValue { get; set; }

    /// <summary>
    /// Gets or sets the uncontrolled default values for a range slider when it is initially rendered.
    /// To render a controlled range slider, use <see cref="Values"/> instead.
    /// </summary>
    [Parameter]
    public double[]? DefaultValues { get; set; }

    /// <summary>
    /// Gets or sets the minimum allowed value of the slider.
    /// Should not be equal to <see cref="Max"/>.
    /// Defaults to <c>0</c>.
    /// </summary>
    [Parameter]
    public double Min { get; set; }

    /// <summary>
    /// Gets or sets the maximum allowed value of the slider.
    /// Should not be equal to <see cref="Min"/>.
    /// Defaults to <c>100</c>.
    /// </summary>
    [Parameter]
    public double Max { get; set; } = 100;

    /// <summary>
    /// Gets or sets the granularity with which the slider can step through values.
    /// The <see cref="Min"/> value serves as the origin for valid values.
    /// Defaults to <c>1</c>.
    /// </summary>
    [Parameter]
    public double Step { get; set; } = 1;

    /// <summary>
    /// Gets or sets the granularity used when stepping with Page Up/Page Down or Shift + Arrow keys.
    /// Defaults to <c>10</c>.
    /// </summary>
    [Parameter]
    public double LargeStep { get; set; } = 10;

    /// <summary>
    /// Gets or sets the minimum number of steps between values in a range slider.
    /// Defaults to <c>0</c>.
    /// </summary>
    [Parameter]
    public int MinStepsBetweenValues { get; set; }

    /// <summary>
    /// Gets or sets the orientation of the slider.
    /// Defaults to <see cref="Orientation.Horizontal"/>.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;

    /// <summary>
    /// Determines whether the slider should ignore user interaction.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Determines whether the slider is read-only.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool ReadOnly { get; set; }

    /// <summary>
    /// Determines whether the slider is required for form submission.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }

    /// <summary>
    /// Gets or sets the name that identifies the field when a form is submitted.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets how thumbs behave when they collide during pointer interactions.
    /// Defaults to <see cref="ThumbCollisionBehavior.Push"/>.
    /// </summary>
    [Parameter]
    public ThumbCollisionBehavior ThumbCollisionBehavior { get; set; } = ThumbCollisionBehavior.Push;

    /// <summary>
    /// Gets or sets how the thumb(s) are aligned relative to the control when the value is at <see cref="Min"/> or <see cref="Max"/>.
    /// Defaults to <see cref="ThumbAlignment.Center"/>.
    /// </summary>
    [Parameter]
    public ThumbAlignment ThumbAlignment { get; set; } = ThumbAlignment.Center;

    /// <summary>
    /// Gets or sets the number format options used to format the slider value.
    /// </summary>
    [Parameter]
    public NumberFormatOptions? Format { get; set; }

    /// <summary>
    /// Gets or sets the locale used when formatting the value.
    /// Defaults to the user's runtime locale.
    /// </summary>
    [Parameter]
    public string? Locale { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the value changes, for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<double> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the values change in a range slider, for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<double[]> ValuesChanged { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the slider value changes.
    /// The event can be canceled by calling <see cref="SliderValueChangeEventArgs{TValue}.Cancel"/>.
    /// </summary>
    [Parameter]
    public EventCallback<SliderValueChangeEventArgs<double>> OnValueChange { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the range slider values change.
    /// The event can be canceled by calling <see cref="SliderValueChangeEventArgs{TValue}.Cancel"/>.
    /// </summary>
    [Parameter]
    public EventCallback<SliderValueChangeEventArgs<double[]>> OnValuesChange { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the slider value is committed (e.g., on pointer up or keyboard input).
    /// </summary>
    [Parameter]
    public EventCallback<SliderValueCommittedEventArgs<double>> OnValueCommitted { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the range slider values are committed (e.g., on pointer up or keyboard input).
    /// </summary>
    [Parameter]
    public EventCallback<SliderValueCommittedEventArgs<double[]>> OnValuesCommitted { get; set; }

    /// <summary>
    /// Gets or sets a custom render fragment that replaces the default element.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<SliderRootState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS class based on the component's state.
    /// </summary>
    [Parameter]
    public Func<SliderRootState, string>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets a function that returns an inline style based on the component's state.
    /// </summary>
    [Parameter]
    public Func<SliderRootState, string>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    private bool IsControlled => Value.HasValue || Values is not null;

    private bool IsRange => Values is not null || DefaultValues is not null || currentValues.Length > 1;

    private bool HasRealtimeSubscribers =>
        realtimeSubscriberCount > 0 ||
        OnValueChange.HasDelegate ||
        OnValuesChange.HasDelegate ||
        ValueChanged.HasDelegate ||
        ValuesChanged.HasDelegate;

    private bool ResolvedDisabled => Disabled || (FieldContext?.Disabled ?? false);

    private string? ResolvedName => Name ?? FieldContext?.Name;

    private string ResolvedId => AttributeUtilities.GetIdOrDefault(AdditionalAttributes, () => defaultId ??= Guid.NewGuid().ToIdString());

    private FieldRootState FieldState => FieldContext?.State ?? FieldRootState.Default;

    private SliderRootState CurrentState => SliderRootState.FromFieldState(
        FieldState,
        activeThumbIndex,
        ResolvedDisabled,
        dragging,
        Max,
        Min,
        MinStepsBetweenValues,
        Orientation,
        ReadOnly,
        Required,
        Step,
        currentValues);

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        InitializeValues();

        context = new SliderRootContext
        {
            SetActiveThumbIndex = SetActiveThumbIndex,
            SetDragging = SetDragging,
            SetValue = SetValue,
            SetValueSilent = SetValueSilent,
            CommitValue = CommitValue,
            HandleInputChange = HandleInputChange,
            RegisterThumb = RegisterThumb,
            UnregisterThumb = UnregisterThumb,
            GetThumbMetadata = GetThumbMetadata,
            GetAllThumbMetadata = GetAllThumbMetadata,
            SetControlElement = SetControlElement,
            SetIndicatorElement = SetIndicatorElement,
            GetIndicatorElement = GetIndicatorElement,
            RegisterRealtimeSubscriber = RegisterRealtimeSubscriber,
            UnregisterRealtimeSubscriber = UnregisterRealtimeSubscriber
        };

        var initialValue = IsRange ? (object)currentValues : currentValues[0];
        FieldContext?.Validation.SetInitialValue(initialValue);
        FieldContext?.SetFilled(currentValues.Any(v => Math.Abs(v - Min) > Epsilon));
        FieldContext?.RegisterFocusHandlerFunc(FocusFirstThumbAsync);
        FieldContext?.SubscribeFunc(this);

        previousValues = [..currentValues];

        state = CurrentState;
        UpdateContext();
        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        if (IsControlled)
        {
            var newValues = GetControlledValues();
            if (!ValuesEqual(newValues, currentValues))
            {
                currentValues = newValues;
            }
        }

        if (hasRendered && !ValuesEqual(currentValues, previousValues))
        {
            previousValues = [..currentValues];
            HandleValuesChanged();
        }

        state = CurrentState;
        UpdateContext();
        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            await InitializeJsAsync();
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        LabelableContext?.SetControlId(null);
        FieldContext?.UnsubscribeFunc(this);

        if (moduleTask?.IsValueCreated == true)
        {
            try
            {
                var module = await ModuleTask.Value;
                if (controlElement.HasValue)
                {
                    await module.InvokeVoidAsync("dispose", controlElement.Value);
                }
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }
    }

    /// <summary>
    /// Notifies the component that its field state has changed and triggers a re-render.
    /// </summary>
    public void NotifyStateChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();
        var orientationStr = state.Orientation.ToDataAttributeString() ?? "horizontal";

        attrs["id"] = ResolvedId;
        attrs["role"] = "group";

        if (!string.IsNullOrEmpty(LabelableContext?.LabelId))
        {
            attrs["aria-labelledby"] = LabelableContext.LabelId;
        }

        attrs["data-dragging"] = state.Dragging;
        attrs["data-orientation"] = orientationStr;
        attrs["data-disabled"] = state.Disabled;
        attrs["data-valid"] = state.Valid == true;
        attrs["data-invalid"] = state.Valid == false;
        attrs["data-touched"] = state.Touched;
        attrs["data-dirty"] = state.Dirty;
        attrs["data-focused"] = state.Focused;

        componentAttributes = attrs;
    }

    private void UpdateContext()
    {
        context.ActiveThumbIndex = activeThumbIndex;
        context.LastUsedThumbIndex = lastUsedThumbIndex;
        context.ControlElement = controlElement;
        context.Dragging = dragging;
        context.Disabled = ResolvedDisabled;
        context.ReadOnly = ReadOnly;
        context.LargeStep = LargeStep;
        context.Max = Max;
        context.Min = Min;
        context.MinStepsBetweenValues = MinStepsBetweenValues;
        context.Name = ResolvedName;
        context.Orientation = Orientation;
        context.Step = Step;
        context.ThumbCollisionBehavior = ThumbCollisionBehavior;
        context.ThumbAlignment = ThumbAlignment;
        context.Values = currentValues;
        context.State = state;
        context.LabelId = LabelableContext?.LabelId;
        context.FormatOptions = Format;
        context.Locale = Locale;
        context.Validation = FieldContext?.Validation;
        context.HasRealtimeSubscribers = HasRealtimeSubscribers;
    }

    private void InitializeValues()
    {
        if (Value.HasValue)
        {
            currentValues = [SliderUtilities.Clamp(Value.Value, Min, Max)];
        }
        else if (Values is not null)
        {
            currentValues = Values.Select(v => SliderUtilities.Clamp(v, Min, Max)).OrderBy(v => v).ToArray();
        }
        else if (DefaultValue.HasValue)
        {
            currentValues = [SliderUtilities.Clamp(DefaultValue.Value, Min, Max)];
        }
        else if (DefaultValues is not null)
        {
            currentValues = DefaultValues.Select(v => SliderUtilities.Clamp(v, Min, Max)).OrderBy(v => v).ToArray();
        }
        else
        {
            currentValues = [Min];
        }
    }

    private double[] GetControlledValues()
    {
        if (Value.HasValue)
        {
            return [SliderUtilities.Clamp(Value.Value, Min, Max)];
        }
        if (Values is not null)
        {
            return Values.Select(v => SliderUtilities.Clamp(v, Min, Max)).OrderBy(v => v).ToArray();
        }
        return currentValues;
    }

    private static bool ValuesEqual(double[] a, double[] b)
    {
        if (a.Length != b.Length) return false;
        for (var i = 0; i < a.Length; i++)
        {
            if (Math.Abs(a[i] - b[i]) > Epsilon) return false;
        }
        return true;
    }

    private void SetActiveThumbIndex(int index)
    {
        if (activeThumbIndex != index)
        {
            activeThumbIndex = index;
            if (index >= 0)
            {
                lastUsedThumbIndex = index;
            }
            if (!dragging)
            {
                state = CurrentState;
                UpdateContext();
                BuildComponentAttributes();
                StateHasChanged();
            }
        }
    }

    private void SetDragging(bool value)
    {
        if (dragging != value)
        {
            dragging = value;
            if (!value)
            {
                state = CurrentState;
                UpdateContext();
                BuildComponentAttributes();
                StateHasChanged();
            }
        }
    }

    private void SetValueSilent(double[] newValues)
    {
        if (!IsControlled)
        {
            currentValues = [..newValues];
        }
    }

    private void SetValue(double[] newValues, SliderChangeReason reason, int thumbIndex)
    {
        if (ValuesEqual(newValues, currentValues))
            return;

        if (IsRange)
        {
            var eventArgs = new SliderValueChangeEventArgs<double[]>(newValues, reason, thumbIndex);
            if (OnValuesChange.HasDelegate)
            {
                _ = InvokeAsync(async () =>
                {
                    await OnValuesChange.InvokeAsync(eventArgs);
                    if (!eventArgs.IsCanceled)
                    {
                        ApplyValueChange(newValues);
                    }
                });
                return;
            }
        }
        else
        {
            var eventArgs = new SliderValueChangeEventArgs<double>(newValues[0], reason, thumbIndex);
            if (OnValueChange.HasDelegate)
            {
                _ = InvokeAsync(async () =>
                {
                    await OnValueChange.InvokeAsync(eventArgs);
                    if (!eventArgs.IsCanceled)
                    {
                        ApplyValueChange(newValues);
                    }
                });
                return;
            }
        }

        ApplyValueChange(newValues);
    }

    private void ApplyValueChange(double[] newValues)
    {
        if (!IsControlled)
        {
            currentValues = [..newValues];
        }

        if (IsRange && ValuesChanged.HasDelegate)
        {
            _ = ValuesChanged.InvokeAsync(newValues);
        }
        else if (!IsRange && ValueChanged.HasDelegate)
        {
            _ = ValueChanged.InvokeAsync(newValues[0]);
        }

        HandleValuesChanged();
        state = CurrentState;
        UpdateContext();
        BuildComponentAttributes();
        StateHasChanged();
    }

    private void CommitValue(double[] values, SliderChangeReason reason)
    {
        if (IsRange)
        {
            if (OnValuesCommitted.HasDelegate)
            {
                var eventArgs = new SliderValueCommittedEventArgs<double[]>(values, reason);
                _ = OnValuesCommitted.InvokeAsync(eventArgs);
            }
        }
        else
        {
            if (OnValueCommitted.HasDelegate)
            {
                var eventArgs = new SliderValueCommittedEventArgs<double>(values[0], reason);
                _ = OnValueCommitted.InvokeAsync(eventArgs);
            }
        }

        FieldContext?.SetTouched(true);

        if (FieldContext?.ValidationMode == ValidationMode.OnBlur)
        {
            var value = IsRange ? (object)values : values[0];
            _ = FieldContext.Validation.CommitAsync(value);
        }
    }

    private void HandleInputChange(double value, int index, SliderChangeReason reason)
    {
        var newValues = SliderUtilities.GetSliderValue(value, index, Min, Max, IsRange, currentValues);

        if (!SliderUtilities.ValidateMinimumDistance(newValues, Step, MinStepsBetweenValues))
            return;

        SetValue(newValues, reason, index);
        CommitValue(newValues, reason);
    }

    private void RegisterThumb(int index, ThumbMetadata metadata)
    {
        thumbRegistry[index] = metadata;
    }

    private void UnregisterThumb(int index)
    {
        thumbRegistry.Remove(index);
    }

    private ThumbMetadata? GetThumbMetadata(int index) =>
        thumbRegistry.TryGetValue(index, out var metadata) ? metadata : null;

    private IReadOnlyDictionary<int, ThumbMetadata> GetAllThumbMetadata() => thumbRegistry;

    private void SetControlElement(ElementReference element)
    {
        controlElement = element;
    }

    private void SetIndicatorElement(ElementReference element)
    {
        indicatorElement = element;
    }

    private ElementReference? GetIndicatorElement() => indicatorElement;

    private void RegisterRealtimeSubscriber()
    {
        Interlocked.Increment(ref realtimeSubscriberCount);
    }

    private void UnregisterRealtimeSubscriber()
    {
        Interlocked.Decrement(ref realtimeSubscriberCount);
    }

    private void HandleValuesChanged()
    {
        FormContext?.ClearErrors(ResolvedName);

        var initialValue = FieldContext?.ValidityData.InitialValue;
        bool isDirty;

        if (IsRange)
        {
            isDirty = initialValue is double[] initial ? !ValuesEqual(currentValues, initial) : true;
        }
        else
        {
            isDirty = initialValue is double initial ? Math.Abs(currentValues[0] - initial) > Epsilon : Math.Abs(currentValues[0] - Min) > Epsilon;
        }

        FieldContext?.SetDirty(isDirty);
        FieldContext?.SetFilled(currentValues.Any(v => Math.Abs(v - Min) > Epsilon));

        if (FieldContext?.ShouldValidateOnChangeFunc() == true)
        {
            var value = IsRange ? (object)currentValues : currentValues[0];
            _ = FieldContext.Validation.CommitAsync(value);
        }
        else
        {
            var value = IsRange ? (object)currentValues : currentValues[0];
            _ = FieldContext?.Validation.CommitAsync(value, revalidateOnly: true);
        }
    }

    private async Task InitializeJsAsync()
    {
        if (!controlElement.HasValue)
            return;

        try
        {
            var module = await ModuleTask.Value;
            var orientationStr = Orientation.ToDataAttributeString() ?? "horizontal";
            await module.InvokeVoidAsync("initialize", controlElement.Value, null, ResolvedDisabled, ReadOnly, orientationStr);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async ValueTask FocusFirstThumbAsync()
    {
        var firstThumb = thumbRegistry.OrderBy(kvp => kvp.Key).FirstOrDefault();
        if (firstThumb.Value is null)
            return;

        try
        {
            var module = await ModuleTask.Value;
            await module.InvokeVoidAsync("focusThumbInput", firstThumb.Value.ThumbElement);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }
}
