@using Microsoft.AspNetCore.Components.Web
@using BlazorBaseUI.Field
@using BlazorBaseUI.Form
@using BlazorBaseUI.Utilities.LabelableProvider
@using BlazorBaseUI.Checkbox

@implements IReferencableComponent
@implements IDisposable
@implements IFieldStateSubscriber

<CascadingValue Value="context" IsFixed="true">
    <RenderElement TState="CheckboxGroupState"
                   Tag="div"
                   State="state"
                   Render="Render"
                   ClassValue="ClassValue"
                   StyleValue="StyleValue"
                   ComponentAttributes="componentAttributes"
                   ChildContent="ChildContent"
                   @attributes="AdditionalAttributes"
                   @ref="renderElementReference" />
</CascadingValue>

@code {
    private string? defaultId;
    private string groupId = null!;
    private string[]? internalValue;
    private string[]? previousValue;
    private CheckboxRoot? controlRef;
    private CheckboxGroupState state = CheckboxGroupState.Default;
    private CheckboxGroupContext? context;
    private RenderElement<CheckboxGroupState>? renderElementReference;
    private Dictionary<string, object> componentAttributes = new();
    private bool previousDisabled;
    private bool? previousValid;
    private bool previousTouched;
    private bool previousDirty;
    private bool previousFilled;
    private bool previousFocused;

    private bool IsControlled => Value is not null;

    private string[]? CurrentValue => IsControlled ? Value : internalValue;

    private bool ResolvedDisabled => Disabled || (FieldContext?.Disabled ?? false);

    private string? ResolvedName => FieldContext?.Name;

    private FieldRootState FieldState => FieldContext?.State ?? FieldRootState.Default;

    private string ResolvedId => AttributeUtilities.GetIdOrDefault(AdditionalAttributes, () => defaultId ??= Guid.NewGuid().ToIdString());

    [CascadingParameter]
    private FieldRootContext? FieldContext { get; set; }

    [CascadingParameter]
    private FormContext? FormContext { get; set; }

    [CascadingParameter]
    private LabelableContext? LabelableContext { get; set; }

    /// <summary>
    /// Gets or sets the names of the checkboxes in the group that should be ticked.
    /// To render an uncontrolled checkbox group, use <see cref="DefaultValue"/> instead.
    /// </summary>
    [Parameter]
    public string[]? Value { get; set; }

    /// <summary>
    /// Gets or sets the names of the checkboxes in the group that should be initially ticked.
    /// To render a controlled checkbox group, use <see cref="Value"/> instead.
    /// </summary>
    [Parameter]
    public string[]? DefaultValue { get; set; }

    /// <summary>
    /// Gets or sets the names of all checkboxes in the group.
    /// Use this when creating a parent checkbox.
    /// </summary>
    [Parameter]
    public string[]? AllValues { get; set; }

    /// <summary>
    /// Determines whether the component should ignore user interaction.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the value changes via two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<string[]> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when a checkbox in the group is ticked or unticked.
    /// Provides the new value as an argument.
    /// </summary>
    [Parameter]
    public EventCallback<CheckboxGroupValueChangeEventArgs> OnValueChange { get; set; }

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<CheckboxGroupState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS class based on the component's state.
    /// </summary>
    [Parameter]
    public Func<CheckboxGroupState, string>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS style based on the component's state.
    /// </summary>
    [Parameter]
    public Func<CheckboxGroupState, string>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        groupId = ResolvedId;

        if (!IsControlled)
        {
            internalValue = DefaultValue ?? [];
        }

        var initialValue = CurrentValue ?? [];
        FieldContext?.Validation.SetInitialValue(initialValue);
        FieldContext?.SetFilled(initialValue.Length > 0);
        FieldContext?.SubscribeFunc(this);

        previousValue = CurrentValue;
        previousDisabled = ResolvedDisabled;
        previousValid = FieldState.Valid;
        previousTouched = FieldState.Touched;
        previousDirty = FieldState.Dirty;
        previousFilled = FieldState.Filled;
        previousFocused = FieldState.Focused;

        state = CheckboxGroupState.FromFieldState(FieldState, ResolvedDisabled);
        context = CreateContext();

        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        var currentDisabled = ResolvedDisabled;
        var fieldState = FieldState;

        var stateChanged = previousDisabled != currentDisabled ||
                           previousValid != fieldState.Valid ||
                           previousTouched != fieldState.Touched ||
                           previousDirty != fieldState.Dirty ||
                           previousFilled != fieldState.Filled ||
                           previousFocused != fieldState.Focused;

        if (stateChanged)
        {
            state = CheckboxGroupState.FromFieldState(fieldState, currentDisabled);
        }

        var valueChanged = !ArraysEqual(CurrentValue, previousValue);

        if (stateChanged || valueChanged)
        {
            context = CreateContext();
        }

        BuildComponentAttributes();

        previousDisabled = currentDisabled;
        previousValid = fieldState.Valid;
        previousTouched = fieldState.Touched;
        previousDirty = fieldState.Dirty;
        previousFilled = fieldState.Filled;
        previousFocused = fieldState.Focused;

        if (valueChanged)
        {
            previousValue = CurrentValue;
            _ = InvokeAsync(async () =>
            {
                try
                {
                    await HandleValueChangedAsync();
                }
                catch (Exception ex)
                {
                    await DispatchExceptionAsync(ex);
                }
            });
        }
    }

    /// <inheritdoc />
    public void Dispose()
    {
        FieldContext?.UnsubscribeFunc(this);
    }

    /// <inheritdoc />
    public void NotifyStateChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();

        attrs["id"] = groupId;
        attrs["role"] = "group";

        if (!string.IsNullOrEmpty(LabelableContext?.LabelId))
        {
            attrs["aria-labelledby"] = LabelableContext.LabelId;
        }

        var describedBy = LabelableContext?.GetAriaDescribedBy();
        if (!string.IsNullOrEmpty(describedBy))
        {
            attrs["aria-describedby"] = describedBy;
        }

        attrs["data-disabled"] = state.Disabled;
        attrs["data-valid"] = state.Valid == true;
        attrs["data-invalid"] = state.Valid == false;
        attrs["data-touched"] = state.Touched;
        attrs["data-dirty"] = state.Dirty;
        attrs["data-filled"] = state.Filled;
        attrs["data-focused"] = state.Focused;

        componentAttributes = attrs;
    }

    private CheckboxGroupContext CreateContext()
    {
        CheckboxGroupParent? parent = null;
        if (AllValues is not null)
        {
            parent = new CheckboxGroupParent
            {
                Id = groupId,
                AllValues = AllValues,
                DefaultValue = DefaultValue,
                GetValue = () => CurrentValue,
                SetValue = SetValueInternal
            };
        }

        return new CheckboxGroupContext
        {
            Value = CurrentValue,
            DefaultValue = DefaultValue,
            AllValues = AllValues,
            Disabled = ResolvedDisabled,
            Parent = parent,
            Validation = FieldContext?.Validation,
            SetValueFunc = SetValueInternal,
            RegisterControlAction = RegisterControl
        };
    }

    private void RegisterControl(CheckboxRoot checkbox)
    {
        if (controlRef is null && !checkbox.Parent)
        {
            controlRef = checkbox;
            FieldContext?.RegisterFocusHandlerFunc(async () =>
            {
                if (controlRef?.Element is not null)
                {
                    await controlRef.Element.Value.FocusAsync();
                }
            });
        }
    }

    private async Task SetValueInternal(string[] newValue)
    {
        var eventArgs = new CheckboxGroupValueChangeEventArgs(newValue);

        if (OnValueChange.HasDelegate)
        {
            await OnValueChange.InvokeAsync(eventArgs);

            if (eventArgs.IsCanceled)
            {
                return;
            }
        }

        if (!IsControlled)
        {
            internalValue = newValue;
        }

        if (ValueChanged.HasDelegate)
        {
            await ValueChanged.InvokeAsync(newValue);
        }

        context = CreateContext();
        BuildComponentAttributes();
        await HandleValueChangedAsync();
        StateHasChanged();
    }

    private async Task HandleValueChangedAsync()
    {
        var currentValue = CurrentValue ?? [];

        FormContext?.ClearErrors(ResolvedName);

        var initialValue = FieldContext?.ValidityData.InitialValue;
        var isDirty = initialValue is string[] initial ? !ArraysEqual(currentValue, initial) : currentValue.Length > 0;

        FieldContext?.SetDirty(isDirty);
        FieldContext?.SetFilled(currentValue.Length > 0);

        if (FieldContext?.ShouldValidateOnChangeFunc() == true)
        {
            await FieldContext.Validation.CommitAsync(currentValue);
        }
        else
        {
            await (FieldContext?.Validation.CommitAsync(currentValue, revalidateOnly: true) ?? Task.CompletedTask);
        }
    }

    private static bool ArraysEqual(string[]? a, string[]? b)
    {
        if (a is null && b is null)
        {
            return true;
        }

        if (a is null || b is null)
        {
            return false;
        }

        if (a.Length != b.Length)
        {
            return false;
        }

        var sortedA = a.OrderBy(x => x).ToArray();
        var sortedB = b.OrderBy(x => x).ToArray();

        return sortedA.SequenceEqual(sortedB);
    }
}
