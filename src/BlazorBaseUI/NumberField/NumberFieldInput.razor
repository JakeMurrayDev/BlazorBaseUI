@using System.Globalization
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Web
@using BlazorBaseUI.Field
@using BlazorBaseUI.Utilities.LabelableProvider


<RenderElement TState="NumberFieldRootState"
               Tag="@DefaultTag"
               State="state"
               Render="Render"
               ClassValue="ClassValue"
               StyleValue="StyleValue"
               ComponentAttributes="componentAttributes"
               ChildContent="ChildContent"
               @attributes="AdditionalAttributes"
               @ref="renderElementReference" />

@code {
    private const string DefaultTag = "input";

    private static readonly Regex ArabicIndicRe = ArabicIndicRegex();
    private static readonly Regex ExtendedArabicIndicRe = ExtendedArabicIndicRegex();
    private static readonly Regex FullwidthRe = FullwidthRegex();
    private static readonly Regex HanRe = HanRegex();

    private bool hasTouchedInput;
    private RenderElement<NumberFieldRootState>? renderElementReference;
    private NumberFieldRootState state = NumberFieldRootState.Default;
    private Dictionary<string, object> componentAttributes = new();

    private CultureInfo ResolvedCulture
    {
        get
        {
            var locale = RootContext?.Locale;
            if (!string.IsNullOrEmpty(locale))
            {
                try { return CultureInfo.GetCultureInfo(locale); }
                catch { return CultureInfo.CurrentCulture; }
            }
            return CultureInfo.CurrentCulture;
        }
    }

    [CascadingParameter]
    private NumberFieldRootContext? RootContext { get; set; }

    [CascadingParameter]
    private FieldRootContext? FieldContext { get; set; }

    [CascadingParameter]
    private LabelableContext? LabelableContext { get; set; }

    /// <summary>
    /// Gets or sets a user-friendly name for the role of the input.
    /// Defaults to <c>"Number field"</c>.
    /// </summary>
    [Parameter]
    public string AriaRoledescription { get; set; } = "Number field";

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<NumberFieldRootState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS class based on the component's state.
    /// </summary>
    [Parameter]
    public Func<NumberFieldRootState, string?>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS style based on the component's state.
    /// </summary>
    [Parameter]
    public Func<NumberFieldRootState, string?>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        state = RootContext?.State ?? NumberFieldRootState.Default;
        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && Element.HasValue)
        {
            RootContext?.SetInputElement(Element.Value);
        }
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();
        if (!string.IsNullOrEmpty(RootContext?.Id))
            attrs["id"] = RootContext!.Id!;
        attrs["type"] = "text";
        attrs["inputmode"] = RootContext?.InputMode ?? "numeric";
        attrs["autocomplete"] = "off";
        attrs["autocorrect"] = "off";
        attrs["spellcheck"] = "false";
        attrs["aria-roledescription"] = AriaRoledescription;
        if (RootContext?.Invalid == true)
            attrs["aria-invalid"] = "true";
        if (!string.IsNullOrEmpty(LabelableContext?.LabelId))
            attrs["aria-labelledby"] = LabelableContext!.LabelId!;
        attrs["value"] = RootContext?.InputValue ?? string.Empty;
        attrs["disabled"] = RootContext?.Disabled ?? false;
        attrs["readonly"] = RootContext?.ReadOnly ?? false;
        attrs["required"] = RootContext?.Required ?? false;
        attrs["onfocus"] = EventCallback.Factory.Create<FocusEventArgs>(this, HandleFocus);
        attrs["onblur"] = EventCallback.Factory.Create<FocusEventArgs>(this, HandleBlur);
        attrs["oninput"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleInput);
        attrs["onkeydown"] = EventCallback.Factory.Create<KeyboardEventArgs>(this, HandleKeyDown);
        attrs["onpaste"] = EventCallback.Factory.Create<ClipboardEventArgs>(this, HandlePaste);
        attrs["data-scrubbing"] = state.Scrubbing;
        attrs["data-disabled"] = state.Disabled;
        attrs["data-readonly"] = state.ReadOnly;
        attrs["data-required"] = state.Required;
        if (state.Valid == true)
            attrs["data-valid"] = true;
        else if (state.Valid == false)
            attrs["data-invalid"] = true;
        attrs["data-touched"] = state.Touched;
        attrs["data-dirty"] = state.Dirty;
        attrs["data-filled"] = state.Filled;
        attrs["data-focused"] = state.Focused;
        componentAttributes = attrs;
    }

    private Task HandleFocus(FocusEventArgs e)
    {
        if (RootContext?.ReadOnly == true || RootContext?.Disabled == true)
            return Task.CompletedTask;

        if (!hasTouchedInput)
        {
            hasTouchedInput = true;
        }

        FieldContext?.SetFocused(true);
        return EventUtilities.InvokeOnFocusAsync(AdditionalAttributes, e);
    }

    private Task HandleBlur(FocusEventArgs e)
    {
        if (RootContext?.ReadOnly == true || RootContext?.Disabled == true)
            return Task.CompletedTask;

        FieldContext?.SetTouched(true);
        FieldContext?.SetFocused(false);

        var inputValue = RootContext?.InputValue ?? string.Empty;

        if (string.IsNullOrWhiteSpace(inputValue))
        {
            RootContext?.SetValue(null, NumberFieldChangeReason.InputClear, null);
            RootContext?.OnValueCommitted(null, NumberFieldChangeReason.InputClear);
            return EventUtilities.InvokeOnBlurAsync(AdditionalAttributes, e);
        }

        var parsedValue = ParseNumber(inputValue);
        if (parsedValue.HasValue)
        {
            var format = RootContext?.FormatOptions;
            var hasExplicitPrecision =
                format?.MaximumFractionDigits is not null ||
                format?.MinimumFractionDigits is not null;
            var maxFrac = format?.MaximumFractionDigits;

            var committed = hasExplicitPrecision && maxFrac.HasValue
                ? Math.Round(parsedValue.Value, maxFrac.Value, MidpointRounding.AwayFromZero)
                : parsedValue.Value;

            var currentValue = RootContext?.Value;
            if (currentValue != committed)
            {
                RootContext?.SetValue(committed, NumberFieldChangeReason.InputBlur, null);
            }
            RootContext?.OnValueCommitted(committed, NumberFieldChangeReason.InputBlur);

            var formattedValue = FormatNumber(committed);
            if (inputValue != formattedValue)
            {
                RootContext?.SetInputValue(formattedValue);
            }
        }

        return EventUtilities.InvokeOnBlurAsync(AdditionalAttributes, e);
    }

    private void HandleInput(ChangeEventArgs e)
    {
        var newValue = e.Value?.ToString() ?? string.Empty;

        if (string.IsNullOrWhiteSpace(newValue))
        {
            RootContext?.SetInputValue(newValue);
            RootContext?.SetValue(null, NumberFieldChangeReason.InputClear, null);
            return;
        }

        if (!IsValidInputCharacters(newValue))
            return;

        RootContext?.SetInputValue(newValue);

        var parsedValue = ParseNumber(newValue);
        if (parsedValue.HasValue)
        {
            RootContext?.SetValue(parsedValue.Value, NumberFieldChangeReason.InputChange, null);
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (RootContext?.ReadOnly == true || RootContext?.Disabled == true)
            return;

        var amount = RootContext?.GetStepAmount(e.AltKey, e.ShiftKey) ?? 1;

        switch (e.Key)
        {
            case "ArrowUp":
                RootContext?.IncrementValue(amount, 1, NumberFieldChangeReason.Keyboard);
                RootContext?.OnValueCommitted(RootContext?.Value, NumberFieldChangeReason.Keyboard);
                break;

            case "ArrowDown":
                RootContext?.IncrementValue(amount, -1, NumberFieldChangeReason.Keyboard);
                RootContext?.OnValueCommitted(RootContext?.Value, NumberFieldChangeReason.Keyboard);
                break;

            case "Home":
                if (RootContext?.Min.HasValue == true)
                {
                    RootContext?.SetValue(RootContext.Min.Value, NumberFieldChangeReason.Keyboard, null);
                    RootContext?.OnValueCommitted(RootContext.Min.Value, NumberFieldChangeReason.Keyboard);
                }
                break;

            case "End":
                if (RootContext?.Max.HasValue == true)
                {
                    RootContext?.SetValue(RootContext.Max.Value, NumberFieldChangeReason.Keyboard, null);
                    RootContext?.OnValueCommitted(RootContext.Max.Value, NumberFieldChangeReason.Keyboard);
                }
                break;
        }
    }

    private void HandlePaste(ClipboardEventArgs e)
    {
        if (RootContext?.ReadOnly == true || RootContext?.Disabled == true)
            return;
    }

    private bool IsValidInputCharacters(string input)
    {
        var culture = ResolvedCulture;
        var decimalSeparator = culture.NumberFormat.NumberDecimalSeparator;
        var groupSeparator = culture.NumberFormat.NumberGroupSeparator;

        foreach (var ch in input)
        {
            var isDigit = char.IsDigit(ch);
            var isDecimal = decimalSeparator.Contains(ch);
            var isGroup = groupSeparator.Contains(ch);
            var isMinus = ch == '-' || ch == '\u2212';
            var isPlus = ch == '+';
            var isSpace = char.IsWhiteSpace(ch);
            var isArabicIndic = ch >= '\u0660' && ch <= '\u0669';
            var isExtendedArabicIndic = ch >= '\u06F0' && ch <= '\u06F9';
            var isFullwidth = ch >= '\uFF10' && ch <= '\uFF19';

            if (!isDigit && !isDecimal && !isGroup && !isMinus && !isPlus && !isSpace
                && !isArabicIndic && !isExtendedArabicIndic && !isFullwidth)
            {
                return false;
            }
        }

        return true;
    }

    private double? ParseNumber(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return null;

        var culture = ResolvedCulture;

        input = NormalizeNumerals(input);
        input = input.Replace('\u2212', '-').Trim();

        if (double.TryParse(input, NumberStyles.Number, culture, out var result))
        {
            return result;
        }

        if (double.TryParse(input, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
        {
            return result;
        }

        return null;
    }

    private static string NormalizeNumerals(string input)
    {
        input = ArabicIndicRe.Replace(input, m => ((char)(m.Value[0] - '\u0660' + '0')).ToString());
        input = ExtendedArabicIndicRe.Replace(input, m => ((char)(m.Value[0] - '\u06F0' + '0')).ToString());
        input = FullwidthRe.Replace(input, m => ((char)(m.Value[0] - '\uFF10' + '0')).ToString());
        input = HanRe.Replace(input, m =>
        {
            var ch = m.Value[0];
            return ch switch
            {
                '\u3007' => "0",
                '\u4E00' => "1",
                '\u4E8C' => "2",
                '\u4E09' => "3",
                '\u56DB' => "4",
                '\u4E94' => "5",
                '\u516D' => "6",
                '\u4E03' => "7",
                '\u516B' => "8",
                '\u4E5D' => "9",
                _ => m.Value
            };
        });

        return input;
    }

    private string FormatNumber(double value)
    {
        var culture = ResolvedCulture;
        var format = RootContext?.FormatOptions;

        if (format is not null)
        {
            var style = format.Style?.ToLowerInvariant();
            var hasExplicitPrecision =
                format.MaximumFractionDigits is not null ||
                format.MinimumFractionDigits is not null;
            var minFrac = format.MinimumFractionDigits ?? 0;
            var maxFrac = format.MaximumFractionDigits ?? 20;

            return style switch
            {
                "currency" => value.ToString($"C{minFrac}", culture),
                "percent" => value.ToString($"P{minFrac}", culture),
                _ => hasExplicitPrecision
                    ? value.ToString($"N{Math.Min(Math.Max(minFrac, 0), maxFrac)}", culture)
                    : value.ToString("G", culture)
            };
        }

        return value.ToString("G", culture);
    }
}
