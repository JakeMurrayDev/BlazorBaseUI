@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Logging
@using BlazorBaseUI.Fieldset
@using BlazorBaseUI.Form
@using BlazorBaseUI.Utilities.LabelableProvider
@using FormValidationMode = BlazorBaseUI.Form.ValidationMode

@implements IReferencableComponent
@implements IDisposable

@inject ILogger<FieldRoot> Logger

<CascadingValue Value="labelableContext">
    <CascadingValue Value="context" IsFixed="true">
        <RenderElement TState="FieldRootState"
                       Tag="div"
                       State="state"
                       Render="Render"
                       ClassValue="ClassValue"
                       StyleValue="StyleValue"
                       ComponentAttributes="componentAttributes"
                       ChildContent="ChildContent"
                       @attributes="AdditionalAttributes"
                       @ref="renderElementReference" />
    </CascadingValue>
</CascadingValue>

@code {
    private readonly HashSet<IFieldStateSubscriber> subscribers = [];

    private Func<Task> cachedLabelableStateChangedCallback = default!;
    private Func<Task> cachedNotifyStateChangedCallback = default!;

    private string? controlId;
    private string? labelId;
    private List<string> messageIds = [];
    private bool labelableNotifyPending;
    private bool touched;
    private bool dirty;
    private bool filled;
    private bool focused;
    private bool notifyPending;
    private bool markedDirty;
    private FieldValidityData validityData = FieldValidityData.Default;
    private FieldValidation validation = null!;
    private FieldRootContext context = null!;
    private LabelableContext labelableContext = null!;
    private FieldRootState state = FieldRootState.Default;
    private string fieldId = null!;
    private EditContext? previousEditContext;
    private Func<ValueTask>? focusHandler;
    private bool previousDisabled;
    private bool? previousValid;
    private bool previousTouched;
    private bool previousDirty;
    private bool previousFilled;
    private bool previousFocused;
    private FieldRootActions? actions;
    private RenderElement<FieldRootState>? renderElementReference;
    private Dictionary<string, object> componentAttributes = new();

    private ValidationMode ResolvedValidationMode =>
        ValidationMode ?? FormContext?.ValidationMode ?? FormValidationMode.OnSubmit;

    private bool ResolvedDisabled => FieldsetContext?.Disabled == true || Disabled;

    private bool ResolvedTouched => TouchedState ?? touched;

    private bool ResolvedDirty => DirtyState ?? dirty;

    [CascadingParameter]
    private EditContext? EditContext { get; set; }

    [CascadingParameter]
    private FormContext? FormContext { get; set; }

    [CascadingParameter]
    private FieldsetRootContext? FieldsetContext { get; set; }

    /// <summary>
    /// Gets or sets the name that identifies the field when a form is submitted.
    /// Takes precedence over the <c>Name</c> property on <see cref="FieldControl{TValue}"/>.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Determines whether the component should ignore user interaction.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets a custom validation function.
    /// Return error message(s) or <see langword="null"/> if valid. Async functions are supported.
    /// </summary>
    [Parameter]
    public Func<object?, Task<string[]?>>? Validate { get; set; }

    /// <summary>
    /// Gets or sets when field validation occurs.
    /// Defaults to <see cref="Form.ValidationMode.OnSubmit"/>.
    /// Takes precedence over the form-level <see cref="Form.Form.ValidationMode"/>.
    /// </summary>
    [Parameter]
    public ValidationMode? ValidationMode { get; set; }

    /// <summary>
    /// Gets or sets how long to wait in milliseconds between validate callbacks
    /// when <see cref="ValidationMode"/> is <see cref="Form.ValidationMode.OnChange"/>.
    /// Defaults to <c>0</c>.
    /// </summary>
    [Parameter]
    public int ValidationDebounceTime { get; set; }

    /// <summary>
    /// Gets or sets whether the field is forcefully marked as invalid.
    /// Useful when field state is controlled by an external library.
    /// </summary>
    [Parameter]
    public bool? Invalid { get; set; }

    /// <summary>
    /// Gets or sets whether the field's value has been changed from its initial value.
    /// Useful when field state is controlled by an external library.
    /// </summary>
    [Parameter]
    public bool? DirtyState { get; set; }

    /// <summary>
    /// Gets or sets whether the field has been touched (i.e., received and lost focus).
    /// Useful when field state is controlled by an external library.
    /// </summary>
    [Parameter]
    public bool? TouchedState { get; set; }

    /// <summary>
    /// Gets or sets a callback that receives a <see cref="FieldRootActions"/> reference for imperative actions.
    /// Includes a <c>ValidateAsync</c> method to validate the field.
    /// </summary>
    [Parameter]
    public Action<FieldRootActions>? ActionsRef { get; set; }

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<FieldRootState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS class based on the component's state.
    /// </summary>
    [Parameter]
    public Func<FieldRootState, string>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS style based on the component's state.
    /// </summary>
    [Parameter]
    public Func<FieldRootState, string>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        fieldId = Guid.NewGuid().ToIdString();
        controlId = fieldId;

        cachedLabelableStateChangedCallback = () =>
        {
            try
            {
                labelableNotifyPending = false;
                labelableContext = CreateLabelableContext();
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error updating labelable state in {Component}", nameof(FieldRoot));
            }
            return Task.CompletedTask;
        };

        cachedNotifyStateChangedCallback = () =>
        {
            try
            {
                ExecuteNotifyStateChanged();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error notifying state changed in {Component}", nameof(FieldRoot));
            }
            return Task.CompletedTask;
        };

        validation = new FieldValidation(
            getValidityData: () => validityData,
            setValidityData: data => validityData = data,
            validate: value => Validate is not null ? Validate(value) : Task.FromResult<string[]?>(null),
            getInvalid: () => Invalid ?? false,
            getMarkedDirty: () => markedDirty,
            debounceTime: ValidationDebounceTime,
            requestStateChange: ScheduleNotifyStateChanged,
            logError: (ex, message) => Logger.LogError(ex, "{Message} in {Component}", message, nameof(FieldRoot)));

        state = new FieldRootState(
            Disabled: ResolvedDisabled,
            Valid: ComputeValid(),
            Touched: ResolvedTouched,
            Dirty: ResolvedDirty,
            Filled: filled,
            Focused: focused);

        context = new FieldRootContext(
            setValidityData: SetValidityData,
            setTouched: SetTouched,
            setDirty: SetDirty,
            setFilled: SetFilled,
            setFocused: SetFocused,
            shouldValidateOnChange: ShouldValidateOnChange,
            registerFocusHandler: RegisterFocusHandler,
            subscribe: Subscribe,
            unsubscribe: Unsubscribe,
            validation: validation);

        labelableContext = CreateLabelableContext();

        actions = new FieldRootActions(ImperativeValidateAsync);
        ActionsRef?.Invoke(actions);

        UpdateContext();
        RegisterWithForm();
        BuildComponentAttributes();

        previousDisabled = ResolvedDisabled;
        previousValid = ComputeValid();
        previousTouched = ResolvedTouched;
        previousDirty = ResolvedDirty;
        previousFilled = filled;
        previousFocused = focused;
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        if (EditContext != previousEditContext)
        {
            DetachValidationStateChangedHandler();
            previousEditContext = EditContext;
            AttachValidationStateChangedHandler();
        }

        var currentDisabled = ResolvedDisabled;
        var currentValid = ComputeValid();
        var currentTouched = ResolvedTouched;
        var currentDirty = ResolvedDirty;

        var stateChanged = previousDisabled != currentDisabled ||
                           previousValid != currentValid ||
                           previousTouched != currentTouched ||
                           previousDirty != currentDirty ||
                           previousFilled != filled ||
                           previousFocused != focused;

        if (stateChanged)
        {
            state = new FieldRootState(
                Disabled: currentDisabled,
                Valid: currentValid,
                Touched: currentTouched,
                Dirty: currentDirty,
                Filled: filled,
                Focused: focused);

            previousDisabled = currentDisabled;
            previousValid = currentValid;
            previousTouched = currentTouched;
            previousDirty = currentDirty;
            previousFilled = filled;
            previousFocused = focused;
        }

        UpdateContext();
        BuildComponentAttributes();
    }

    /// <inheritdoc />
    public void Dispose()
    {
        DetachValidationStateChangedHandler();
        FormContext?.FieldRegistry.Unregister(fieldId);
        validation.Dispose();
        subscribers.Clear();
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();

        attrs["data-disabled"] = state.Disabled;
        attrs["data-valid"] = state.Valid == true;
        attrs["data-invalid"] = state.Valid == false;
        attrs["data-touched"] = state.Touched;
        attrs["data-dirty"] = state.Dirty;
        attrs["data-filled"] = state.Filled;
        attrs["data-focused"] = state.Focused;

        componentAttributes = attrs;
    }

    private bool? ComputeValid()
    {
        if (Invalid == true)
            return false;

        if (EditContext is not null && Name is not null)
        {
            var fieldIdentifier = EditContext.Field(Name);
            if (EditContext.GetValidationMessages(fieldIdentifier).Any())
                return false;
        }

        if (FormContext?.HasError(Name) == true)
            return false;

        if (validityData.State.Valid == false)
            return false;

        return validityData.State.Valid;
    }

    private bool ShouldValidateOnChange() =>
        ResolvedValidationMode == FormValidationMode.OnChange ||
        (ResolvedValidationMode == FormValidationMode.OnSubmit &&
         FormContext?.GetSubmitAttempted() == true);

    private LabelableContext CreateLabelableContext() => new(
        ControlId: controlId,
        SetControlId: SetControlId,
        LabelId: labelId,
        SetLabelId: SetLabelId,
        MessageIds: messageIds,
        UpdateMessageIds: UpdateMessageIds);

    private void ScheduleLabelableStateHasChanged()
    {
        if (labelableNotifyPending)
            return;

        labelableNotifyPending = true;
        _ = InvokeAsync(cachedLabelableStateChangedCallback);
    }

    private void SetControlId(string? id)
    {
        if (controlId == id) return;
        controlId = id;
        ScheduleLabelableStateHasChanged();
    }

    private void SetLabelId(string? id)
    {
        if (labelId == id) return;
        labelId = id;
        ScheduleLabelableStateHasChanged();
    }

    private void UpdateMessageIds(string id, bool add)
    {
        if (add)
        {
            if (messageIds.Contains(id)) return;
            messageIds = [.. messageIds, id];
        }
        else
        {
            if (!messageIds.Contains(id)) return;
            messageIds = messageIds.Where(m => m != id).ToList();
        }
        ScheduleLabelableStateHasChanged();
    }

    private void UpdateContext()
    {
        context.Update(
            invalid: Invalid,
            name: Name,
            validityData: validityData,
            disabled: ResolvedDisabled,
            touched: ResolvedTouched,
            dirty: ResolvedDirty,
            filled: filled,
            focused: focused,
            validationMode: ResolvedValidationMode,
            validationDebounceTime: ValidationDebounceTime,
            state: state);
    }

    private void RegisterWithForm()
    {
        FormContext?.FieldRegistry.Register(fieldId, new FieldRegistration(
            getName: () => Name,
            getValue: () => validityData.Value,
            validateAsync: () => validation.CommitAsync(validityData.Value),
            getValidityData: () => validityData,
            focusAsync: () => focusHandler?.Invoke() ?? ValueTask.CompletedTask));
    }

    private void RegisterFocusHandler(Func<ValueTask> handler)
    {
        focusHandler = handler;
    }

    private void Subscribe(IFieldStateSubscriber subscriber)
    {
        subscribers.Add(subscriber);
    }

    private void Unsubscribe(IFieldStateSubscriber subscriber)
    {
        subscribers.Remove(subscriber);
    }

    private void ScheduleNotifyStateChanged()
    {
        if (notifyPending)
            return;

        notifyPending = true;
        _ = InvokeAsync(cachedNotifyStateChangedCallback);
    }

    private void ExecuteNotifyStateChanged()
    {
        notifyPending = false;

        var currentValid = ComputeValid();
        state = new FieldRootState(
            Disabled: ResolvedDisabled,
            Valid: currentValid,
            Touched: ResolvedTouched,
            Dirty: ResolvedDirty,
            Filled: filled,
            Focused: focused);

        previousDisabled = ResolvedDisabled;
        previousValid = currentValid;
        previousTouched = ResolvedTouched;
        previousDirty = ResolvedDirty;
        previousFilled = filled;
        previousFocused = focused;

        UpdateContext();
        BuildComponentAttributes();
        StateHasChanged();

        foreach (var subscriber in subscribers.ToArray())
        {
            subscriber.NotifyStateChanged();
        }
    }

    private void SetValidityData(FieldValidityData data)
    {
        validityData = data;
        UpdateContext();
    }

    private void SetTouched(bool value)
    {
        if (TouchedState.HasValue) return;
        if (touched == value) return;
        touched = value;
        ScheduleNotifyStateChanged();
    }

    private void SetDirty(bool value)
    {
        if (DirtyState.HasValue) return;
        if (value)
            markedDirty = true;
        if (dirty == value) return;
        dirty = value;
        ScheduleNotifyStateChanged();
    }

    private async Task ImperativeValidateAsync()
    {
        markedDirty = true;
        await validation.CommitAsync(validityData.Value);
    }

    private void SetFilled(bool value)
    {
        if (filled == value) return;
        filled = value;
        ScheduleNotifyStateChanged();
    }

    private void SetFocused(bool value)
    {
        if (focused == value) return;
        focused = value;
        ScheduleNotifyStateChanged();
    }

    private void AttachValidationStateChangedHandler()
    {
        if (EditContext is not null)
        {
            EditContext.OnValidationStateChanged += HandleValidationStateChanged;
        }
    }

    private void DetachValidationStateChangedHandler()
    {
        if (previousEditContext is not null)
        {
            previousEditContext.OnValidationStateChanged -= HandleValidationStateChanged;
        }
    }

    private void HandleValidationStateChanged(object? sender, ValidationStateChangedEventArgs e)
    {
        ScheduleNotifyStateChanged();
    }

    private sealed class FieldRegistration(
        Func<string?> getName,
        Func<object?> getValue,
        Func<Task> validateAsync,
        Func<FieldValidityData> getValidityData,
        Func<ValueTask> focusAsync) : IFieldRegistration
    {
        public string? Name => getName();
        public Func<object?> GetValue => getValue;
        public Func<Task> ValidateAsync => validateAsync;
        public FieldValidityData ValidityData => getValidityData();
        public Func<ValueTask> FocusAsync => focusAsync;
    }
}
