@using BlazorBaseUI.Form
@using BlazorBaseUI.Utilities.LabelableProvider
@using Microsoft.AspNetCore.Components.Forms

@implements IFieldStateSubscriber
@implements IDisposable

<RenderElement TState="FieldRootState"
               Tag="div"
               State="state"
               Render="Render"
               Enabled="shouldRender"
               ClassValue="ClassValue"
               StyleValue="StyleValue"
               ComponentAttributes="componentAttributes"
               ChildContent="resolvedChildContent"
               @attributes="AdditionalAttributes"
               @ref="renderElementReference" />

@code {
    private string? defaultId;
    private bool wasRendered;
    private bool shouldRender;
    private FieldRootState state;
    private RenderElement<FieldRootState>? renderElementReference;
    private Dictionary<string, object> componentAttributes = new();
    private RenderFragment? resolvedChildContent;

    private FieldRootState State => FieldContext?.State ?? FieldRootState.Default;

    private string? FieldName => FieldContext?.Name;

    private string ResolvedId => AttributeUtilities.GetIdOrDefault(AdditionalAttributes, () => defaultId ??= Guid.NewGuid().ToIdString());

    [CascadingParameter]
    private FieldRootContext? FieldContext { get; set; }

    [CascadingParameter]
    private LabelableContext? LabelableContext { get; set; }

    [CascadingParameter]
    private EditContext? EditContext { get; set; }

    [CascadingParameter]
    private FormContext? FormContext { get; set; }

    /// <summary>
    /// Determines whether to show the error message.
    /// When <see langword="true"/>, the error is always shown, letting external libraries control visibility.
    /// </summary>
    [Parameter]
    public bool? Match { get; set; }

    /// <summary>
    /// Gets or sets a validity state name to match against the field's validity.
    /// Supported values: <c>badInput</c>, <c>customError</c>, <c>patternMismatch</c>,
    /// <c>rangeOverflow</c>, <c>rangeUnderflow</c>, <c>stepMismatch</c>, <c>tooLong</c>,
    /// <c>tooShort</c>, <c>typeMismatch</c>, <c>valueMissing</c>.
    /// </summary>
    [Parameter]
    public string? MatchValidity { get; set; }

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<FieldRootState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS class based on the component's state.
    /// </summary>
    [Parameter]
    public Func<FieldRootState, string>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS style based on the component's state.
    /// </summary>
    [Parameter]
    public Func<FieldRootState, string>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        FieldContext?.Subscribe(this);

        state = State;
        shouldRender = ShouldRenderError();
        BuildComponentAttributes();
        BuildResolvedChildContent();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        state = State;
        shouldRender = ShouldRenderError();

        if (shouldRender != wasRendered)
        {
            if (shouldRender)
                LabelableContext?.UpdateMessageIds.Invoke(ResolvedId, true);
            else
                LabelableContext?.UpdateMessageIds.Invoke(ResolvedId, false);

            wasRendered = shouldRender;
        }

        BuildComponentAttributes();
        BuildResolvedChildContent();
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();

        attrs["id"] = ResolvedId;
        attrs["data-disabled"] = state.Disabled;
        attrs["data-valid"] = state.Valid == true;
        attrs["data-invalid"] = state.Valid == false;
        attrs["data-touched"] = state.Touched;
        attrs["data-dirty"] = state.Dirty;
        attrs["data-filled"] = state.Filled;
        attrs["data-focused"] = state.Focused;

        componentAttributes = attrs;
    }

    private void BuildResolvedChildContent()
    {
        if (ChildContent is not null)
        {
            resolvedChildContent = ChildContent;
            return;
        }

        var errorContent = GetErrorContent();

        resolvedChildContent = builder =>
        {
            if (errorContent.formError is not null)
            {
                builder.AddContent(0, errorContent.formError);
            }
            else if (errorContent.validityErrors.Length > 1)
            {
                builder.OpenElement(1, "ul");
                foreach (var error in errorContent.validityErrors)
                {
                    builder.OpenElement(2, "li");
                    builder.AddContent(3, error);
                    builder.CloseElement();
                }
                builder.CloseElement();
            }
            else if (!string.IsNullOrEmpty(errorContent.validityError))
            {
                builder.AddContent(4, errorContent.validityError);
            }
        };
    }

    /// <inheritdoc />
    public void Dispose()
    {
        FieldContext?.Unsubscribe(this);
        if (wasRendered)
            LabelableContext?.UpdateMessageIds.Invoke(ResolvedId, false);
    }

    /// <inheritdoc />
    void IFieldStateSubscriber.NotifyStateChanged()
    {
        state = State;
        shouldRender = ShouldRenderError();

        if (shouldRender != wasRendered)
        {
            if (shouldRender)
                LabelableContext?.UpdateMessageIds.Invoke(ResolvedId, true);
            else
                LabelableContext?.UpdateMessageIds.Invoke(ResolvedId, false);

            wasRendered = shouldRender;
        }

        BuildComponentAttributes();
        BuildResolvedChildContent();
        _ = InvokeAsync(StateHasChanged);
    }

    private bool ShouldRenderError()
    {
        var formError = GetFormError();
        if (formError is not null || Match == true)
            return true;

        if (MatchValidity is not null)
            return MatchValidityState(MatchValidity);

        var validityData = FieldContext?.ValidityData ?? FieldValidityData.Default;
        return validityData.State.Valid == false;
    }

    private bool MatchValidityState(string validity)
    {
        var validityData = FieldContext?.ValidityData ?? FieldValidityData.Default;
        return validity.ToLowerInvariant() switch
        {
            "badinput" => validityData.State.BadInput,
            "customerror" => validityData.State.CustomError,
            "patternmismatch" => validityData.State.PatternMismatch,
            "rangeoverflow" => validityData.State.RangeOverflow,
            "rangeunderflow" => validityData.State.RangeUnderflow,
            "stepmismatch" => validityData.State.StepMismatch,
            "toolong" => validityData.State.TooLong,
            "tooshort" => validityData.State.TooShort,
            "typemismatch" => validityData.State.TypeMismatch,
            "valuemissing" => validityData.State.ValueMissing,
            _ => false
        };
    }

    private string? GetFormError()
    {
        if (FieldName is null)
            return null;

        if (FormContext is not null)
        {
            var formErrors = FormContext.GetErrors(FieldName);
            if (formErrors.Length > 0)
                return formErrors[0];
        }

        if (EditContext is not null)
        {
            var fieldIdentifier = EditContext.Field(FieldName);
            var editContextErrors = EditContext.GetValidationMessages(fieldIdentifier).ToArray();
            if (editContextErrors.Length > 0)
                return editContextErrors[0];
        }

        return null;
    }

    private (string? formError, string[] validityErrors, string? validityError) GetErrorContent()
    {
        var formError = GetFormError();
        var validityData = FieldContext?.ValidityData ?? FieldValidityData.Default;
        return (formError, validityData.Errors, validityData.Error);
    }
}
