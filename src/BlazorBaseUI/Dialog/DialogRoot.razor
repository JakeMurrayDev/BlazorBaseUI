@using Microsoft.JSInterop
@implements IAsyncDisposable
@implements IDialogHandleSubscriber
@inject IJSRuntime JSRuntime

<CascadingValue Value="context" IsFixed="true">
    @if (ChildContentWithPayload is not null)
    {
        @ChildContentWithPayload(new DialogRootPayloadContext(payload))
    }
    else
    {
        @ChildContent
    }
</CascadingValue>

@code {
    private readonly string rootId = Guid.NewGuid().ToIdString();
    private readonly Dictionary<string, ElementReference?> triggerElements = new();
    private readonly Dictionary<string, object?> triggerPayloads = new();

    private Lazy<Task<IJSObjectReference>>? moduleTask;
    private bool hasRendered;
    private bool isOpen;
    private bool isMounted;
    private bool nested;
    private bool pendingOpenChange;
    private bool pendingBindingUpdate;
    private int nestedDialogCount;
    private string? titleId;
    private string? descriptionId;
    private string? activeTriggerId;
    private ElementReference? popupElement;
    private OpenChangeReason openChangeReason = OpenChangeReason.None;
    private TransitionStatus transitionStatus = TransitionStatus.Undefined;
    private InstantType instantType = InstantType.None;
    private object? payload;
    private DialogRootState state;
    private DialogRootContext context = null!;
    private DotNetObjectReference<DialogRoot>? dotNetRef;
    private IDialogHandle? subscribedHandle;

    private Lazy<Task<IJSObjectReference>> ModuleTask => moduleTask ??= new Lazy<Task<IJSObjectReference>>(() =>
        JSRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./_content/BlazorBaseUI/blazor-baseui-dialog.js").AsTask());

    [CascadingParameter]
    private DialogRootContext? ParentContext { get; set; }

    /// <summary>
    /// Gets or sets whether the dialog is currently open.
    /// When set, the component operates in controlled mode.
    /// </summary>
    [Parameter]
    public bool? Open { get; set; }

    /// <summary>
    /// Determines whether the dialog is initially open.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; }

    /// <summary>
    /// Gets or sets the modal behavior of the dialog.
    /// Defaults to <see cref="ModalMode.True"/>.
    /// </summary>
    [Parameter]
    public ModalMode Modal { get; set; } = ModalMode.True;

    /// <summary>
    /// Gets or sets the ARIA role of the dialog.
    /// Defaults to <see cref="DialogRole.Dialog"/>.
    /// </summary>
    [Parameter]
    public DialogRole Role { get; set; } = DialogRole.Dialog;

    /// <summary>
    /// Determines whether the dialog should close when the Escape key is pressed.
    /// Defaults to <see langword="true"/>.
    /// </summary>
    [Parameter]
    public bool DismissOnEscape { get; set; } = true;

    /// <summary>
    /// Determines whether the dialog should close on outside clicks.
    /// Defaults to <see langword="true"/>.
    /// </summary>
    [Parameter]
    public bool DismissOnOutsidePress { get; set; } = true;

    /// <summary>
    /// Gets or sets a reference to imperative actions for controlling the dialog programmatically.
    /// </summary>
    [Parameter]
    public DialogRootActions? ActionsRef { get; set; }

    /// <summary>
    /// Gets or sets a handle to associate the dialog with external triggers.
    /// Allows detached trigger components to control the dialog's open state.
    /// </summary>
    [Parameter]
    public IDialogHandle? Handle { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the open state changes, for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the dialog is opened or closed.
    /// </summary>
    [Parameter]
    public EventCallback<DialogOpenChangeEventArgs> OnOpenChange { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked after any animations complete when the dialog is opened or closed.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OnOpenChangeComplete { get; set; }

    /// <summary>
    /// Gets or sets the ID of the trigger that the dialog is associated with.
    /// This is useful in conjunction with the <see cref="Open"/> property to create a controlled dialog.
    /// </summary>
    [Parameter]
    public string? TriggerId { get; set; }

    /// <summary>
    /// Gets or sets the ID of the trigger that the dialog is initially associated with.
    /// This is useful in conjunction with the <see cref="DefaultOpen"/> property to create an initially open dialog.
    /// </summary>
    [Parameter]
    public string? DefaultTriggerId { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets the child content render fragment that receives the payload context from the active trigger.
    /// </summary>
    [Parameter]
    public RenderFragment<DialogRootPayloadContext>? ChildContentWithPayload { get; set; }

    private bool IsControlled => Open.HasValue;

    private bool IsTriggerIdControlled => TriggerId is not null;

    private bool CurrentOpen => IsControlled ? Open!.Value : isOpen;

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        isOpen = DefaultOpen;
        isMounted = CurrentOpen;
        nested = ParentContext is not null;
        activeTriggerId = IsTriggerIdControlled ? TriggerId : DefaultTriggerId;
        state = new DialogRootState(CurrentOpen, nestedDialogCount);
        context = new DialogRootContext
        {
            RootId = rootId,
            Nested = nested,
            Open = CurrentOpen,
            Mounted = isMounted,
            Modal = Modal,
            Role = Role,
            DismissOnEscape = DismissOnEscape,
            DismissOnOutsidePress = DismissOnOutsidePress,
            NestedDialogCount = nestedDialogCount,
            OpenChangeReason = openChangeReason,
            TransitionStatus = transitionStatus,
            InstantType = instantType,
            TitleId = titleId,
            DescriptionId = descriptionId,
            ActiveTriggerId = activeTriggerId,
            Payload = payload,
            GetOpen = () => CurrentOpen,
            GetMounted = () => isMounted,
            GetPayload = () => payload,
            GetTriggerElement = GetTriggerElement,
            GetPopupElement = () => popupElement,
            SetTitleId = SetTitleId,
            SetDescriptionId = SetDescriptionId,
            RegisterTriggerElement = RegisterTriggerElement,
            UnregisterTriggerElement = UnregisterTriggerElement,
            SetPopupElement = SetPopupElement,
            SetOpenAsync = SetOpenAsync,
            SetOpenWithPayloadAsync = SetOpenWithPayloadAsync,
            SetOpenWithTriggerIdAsync = SetOpenWithTriggerIdAsync,
            SetTriggerPayload = SetTriggerPayload,
            Close = Close,
            ForceUnmount = ForceUnmount
        };

        if (ActionsRef is not null)
        {
            ActionsRef.Unmount = ForceUnmount;
            ActionsRef.Close = () => _ = SetOpenWithExceptionHandlingAsync(false, OpenChangeReason.ImperativeAction);
            ActionsRef.Open = () => _ = SetOpenWithExceptionHandlingAsync(true, OpenChangeReason.ImperativeAction);
            ActionsRef.OpenWithPayload = p => _ = SetOpenWithPayloadWithExceptionHandlingAsync(p, OpenChangeReason.ImperativeAction);
        }

        SubscribeToHandle();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        var currentOpen = pendingBindingUpdate ? state.Open : CurrentOpen;
        if (state.Open != currentOpen)
        {
            state = new DialogRootState(currentOpen, nestedDialogCount);
            if (currentOpen)
            {
                isMounted = true;
                instantType = InstantType.None;
                transitionStatus = TransitionStatus.Starting;
            }
            else
            {
                instantType = InstantType.None;
                transitionStatus = TransitionStatus.Ending;
            }
            context.Open = currentOpen;
            context.Mounted = isMounted;
            context.InstantType = instantType;
            context.TransitionStatus = transitionStatus;
            openChangeReason = OpenChangeReason.None;
            context.OpenChangeReason = openChangeReason;

            if (hasRendered)
            {
                pendingOpenChange = true;
            }
        }

        if (IsTriggerIdControlled && activeTriggerId != TriggerId)
        {
            activeTriggerId = TriggerId;
            context.ActiveTriggerId = activeTriggerId;
        }

        context.Modal = Modal;
        context.Role = Role;
        context.DismissOnEscape = DismissOnEscape;
        context.DismissOnOutsidePress = DismissOnOutsidePress;

        if (ActionsRef is not null)
        {
            ActionsRef.Unmount = ForceUnmount;
            ActionsRef.Close = () => _ = SetOpenWithExceptionHandlingAsync(false, OpenChangeReason.ImperativeAction);
            ActionsRef.Open = () => _ = SetOpenWithExceptionHandlingAsync(true, OpenChangeReason.ImperativeAction);
            ActionsRef.OpenWithPayload = p => _ = SetOpenWithPayloadWithExceptionHandlingAsync(p, OpenChangeReason.ImperativeAction);
        }

        if (Handle != subscribedHandle)
        {
            UnsubscribeFromHandle();
            SubscribeToHandle();
        }
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            dotNetRef = DotNetObjectReference.Create(this);
            await InitializeJsAsync();

            if (CurrentOpen)
            {
                try
                {
                    var module = await ModuleTask.Value;
                    await module.InvokeVoidAsync("setRootOpen", rootId, true);
                }
                catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
                {
                }
            }
        }
        else if (pendingOpenChange)
        {
            pendingOpenChange = false;
            try
            {
                var module = await ModuleTask.Value;
                await module.InvokeVoidAsync("setRootOpen", rootId, CurrentOpen);
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }
    }

    /// <summary>
    /// Handles outside press events from JavaScript interop.
    /// </summary>
    [JSInvokable]
    public async Task OnOutsidePress()
    {
        if (DismissOnOutsidePress)
        {
            await SetOpenAsync(false, OpenChangeReason.OutsidePress);
        }
    }

    /// <summary>
    /// Handles Escape key events from JavaScript interop.
    /// </summary>
    [JSInvokable]
    public async Task OnEscapeKey()
    {
        if (DismissOnEscape)
        {
            await SetOpenAsync(false, OpenChangeReason.EscapeKey);
        }
    }

    /// <summary>
    /// Handles the starting style applied event from JavaScript interop, transitioning from <see cref="TransitionStatus.Starting"/> to <see cref="TransitionStatus.Idle"/>.
    /// </summary>
    [JSInvokable]
    public void OnStartingStyleApplied()
    {
        if (transitionStatus == TransitionStatus.Starting)
        {
            transitionStatus = TransitionStatus.Idle;
            context.TransitionStatus = transitionStatus;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Handles the transition end event from JavaScript interop, completing the open or close animation.
    /// </summary>
    [JSInvokable]
    public void OnTransitionEnd(bool open)
    {
        transitionStatus = TransitionStatus.Idle;
        context.TransitionStatus = transitionStatus;

        if (!open)
        {
            isMounted = false;
            context.Mounted = false;
            activeTriggerId = null;
            context.ActiveTriggerId = null;
            payload = null;
            context.Payload = null;
        }

        instantType = InstantType.None;
        context.InstantType = instantType;

        _ = InvokeOpenChangeCompleteAsync(open);
        StateHasChanged();
    }

    /// <summary>
    /// Handles nested dialog count changes from JavaScript interop.
    /// </summary>
    [JSInvokable]
    public void OnNestedDialogCountChange(int count)
    {
        if (nestedDialogCount == count)
        {
            return;
        }

        nestedDialogCount = count;
        context.NestedDialogCount = count;
        state = state with { NestedDialogCount = count };
        StateHasChanged();
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        UnsubscribeFromHandle();

        if (moduleTask?.IsValueCreated == true && hasRendered)
        {
            try
            {
                var module = await ModuleTask.Value;
                await module.InvokeVoidAsync("disposeRoot", rootId);
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }

        dotNetRef?.Dispose();
    }

    void IDialogHandleSubscriber.OnTriggerRegistered(string triggerId, ElementReference? element)
    {
        triggerElements[triggerId] = element;

        if (hasRendered && element.HasValue && activeTriggerId == triggerId)
        {
            _ = SetTriggerElementJsAsync(element.Value);
        }
    }

    void IDialogHandleSubscriber.OnTriggerUnregistered(string triggerId)
    {
        triggerElements.Remove(triggerId);
        triggerPayloads.Remove(triggerId);
    }

    void IDialogHandleSubscriber.OnTriggerElementUpdated(string triggerId, ElementReference? element)
    {
        triggerElements[triggerId] = element;

        if (hasRendered && element.HasValue && activeTriggerId == triggerId)
        {
            _ = SetTriggerElementJsAsync(element.Value);
        }
    }

    void IDialogHandleSubscriber.OnOpenChangeRequested(bool open, OpenChangeReason reason, string? triggerId)
    {
        _ = InvokeAsync(async () =>
        {
            try
            {
                if (open && triggerId is not null)
                {
                    var handlePayload = GetPayloadFromHandle(triggerId);
                    await SetOpenWithTriggerIdAsync(triggerId, handlePayload, reason);
                }
                else
                {
                    await SetOpenAsync(open, reason);
                }
            }
            catch (Exception ex)
            {
                await DispatchExceptionAsync(ex);
            }
        });
    }

    void IDialogHandleSubscriber.OnStateChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    internal void RegisterTriggerElement(string triggerId, ElementReference? element)
    {
        triggerElements[triggerId] = element;

        if (hasRendered && element.HasValue && activeTriggerId == triggerId)
        {
            _ = SetTriggerElementJsAsync(element.Value);
        }
    }

    internal void UnregisterTriggerElement(string triggerId)
    {
        triggerElements.Remove(triggerId);
        triggerPayloads.Remove(triggerId);
    }

    internal void SetTriggerPayload(string triggerId, object? triggerPayload)
    {
        triggerPayloads[triggerId] = triggerPayload;

        if (activeTriggerId == triggerId && CurrentOpen)
        {
            payload = triggerPayload;
            context.Payload = payload;
        }
    }

    internal ElementReference? GetTriggerElement()
    {
        if (activeTriggerId is not null && triggerElements.TryGetValue(activeTriggerId, out var element))
        {
            return element;
        }

        if (Handle is not null && activeTriggerId is not null)
        {
            var handleElement = GetTriggerElementFromHandle(activeTriggerId);
            if (handleElement.HasValue)
            {
                return handleElement;
            }
        }

        return triggerElements.Values.FirstOrDefault();
    }

    private async Task InitializeJsAsync()
    {
        try
        {
            var module = await ModuleTask.Value;
            await module.InvokeVoidAsync("initializeRoot", rootId, dotNetRef, Modal.ToDataAttributeString());
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private void SetTitleId(string id)
    {
        titleId = id;
        context.TitleId = id;
    }

    private void SetDescriptionId(string id)
    {
        descriptionId = id;
        context.DescriptionId = id;
    }

    private async Task SetTriggerElementJsAsync(ElementReference element)
    {
        try
        {
            var module = await ModuleTask.Value;
            await module.InvokeVoidAsync("setTriggerElement", rootId, element);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private void SetPopupElement(ElementReference? element)
    {
        popupElement = element;

        if (hasRendered && element.HasValue)
        {
            _ = SetPopupElementAsync(element.Value);
        }
    }

    private async Task SetPopupElementAsync(ElementReference element)
    {
        try
        {
            var module = await ModuleTask.Value;
            await module.InvokeVoidAsync("setPopupElement", rootId, element);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task SetOpenAsync(bool nextOpen, OpenChangeReason reason)
    {
        if (CurrentOpen == nextOpen)
        {
            return;
        }

        var args = new DialogOpenChangeEventArgs(nextOpen, reason);
        await OnOpenChange.InvokeAsync(args);

        if (args.Canceled)
        {
            return;
        }

        openChangeReason = reason;
        context.OpenChangeReason = reason;

        if (nextOpen)
        {
            instantType = reason == OpenChangeReason.TriggerPress ? InstantType.Click : InstantType.None;
            transitionStatus = TransitionStatus.Starting;
            isMounted = true;
        }
        else
        {
            instantType = reason switch
            {
                OpenChangeReason.EscapeKey or OpenChangeReason.OutsidePress => InstantType.Dismiss,
                OpenChangeReason.TriggerPress or OpenChangeReason.ClosePress => InstantType.Click,
                _ => InstantType.None
            };
            transitionStatus = TransitionStatus.Ending;
            payload = null;
            context.Payload = null;
        }

        context.InstantType = instantType;
        context.TransitionStatus = transitionStatus;
        context.Mounted = isMounted;

        if (!IsControlled)
        {
            isOpen = nextOpen;
        }

        state = new DialogRootState(nextOpen, nestedDialogCount);
        context.Open = nextOpen;

        SyncHandleState(nextOpen, activeTriggerId);

        if (hasRendered)
        {
            pendingOpenChange = false;

            if (IsControlled)
            {
                pendingBindingUpdate = true;
            }

            try
            {
                var module = await ModuleTask.Value;
                await module.InvokeVoidAsync("setRootOpen", rootId, nextOpen);
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }

        try
        {
            await OpenChanged.InvokeAsync(nextOpen);
        }
        finally
        {
            pendingBindingUpdate = false;
        }

        StateHasChanged();
    }

    private async Task SetOpenWithPayloadAsync(object? newPayload, OpenChangeReason reason)
    {
        payload = newPayload;
        context.Payload = newPayload;
        await SetOpenAsync(true, reason);
    }

    private async Task SetOpenWithTriggerIdAsync(string? triggerId, object? newPayload, OpenChangeReason reason)
    {
        if (!IsTriggerIdControlled)
        {
            activeTriggerId = triggerId;
            context.ActiveTriggerId = activeTriggerId;
        }

        if (newPayload is null && triggerId is not null)
        {
            var handlePayload = GetPayloadFromHandle(triggerId);
            if (handlePayload is not null)
            {
                newPayload = handlePayload;
            }
            else if (triggerPayloads.TryGetValue(triggerId, out var storedPayload))
            {
                newPayload = storedPayload;
            }
        }

        payload = newPayload;
        context.Payload = newPayload;
        await SetOpenAsync(true, reason);
    }

    private async Task SetOpenWithExceptionHandlingAsync(bool nextOpen, OpenChangeReason reason)
    {
        try
        {
            await SetOpenAsync(nextOpen, reason);
        }
        catch (Exception ex)
        {
            await DispatchExceptionAsync(ex);
        }
    }

    private async Task SetOpenWithPayloadWithExceptionHandlingAsync(object? newPayload, OpenChangeReason reason)
    {
        try
        {
            await SetOpenWithPayloadAsync(newPayload, reason);
        }
        catch (Exception ex)
        {
            await DispatchExceptionAsync(ex);
        }
    }

    private void Close()
    {
        _ = SetOpenWithExceptionHandlingAsync(false, OpenChangeReason.ClosePress);
    }

    private void ForceUnmount()
    {
        isMounted = false;
        context.Mounted = false;
        transitionStatus = TransitionStatus.Undefined;
        context.TransitionStatus = transitionStatus;
        activeTriggerId = null;
        context.ActiveTriggerId = null;
        payload = null;
        context.Payload = null;
        _ = InvokeOpenChangeCompleteAsync(false);
        StateHasChanged();
    }

    private async Task InvokeOpenChangeCompleteAsync(bool open)
    {
        try
        {
            await OnOpenChangeComplete.InvokeAsync(open);
        }
        catch (Exception ex)
        {
            await DispatchExceptionAsync(ex);
        }
    }

    private void SubscribeToHandle()
    {
        if (Handle is null)
        {
            return;
        }

        subscribedHandle = Handle;
        Handle.Subscribe(this);
    }

    private void UnsubscribeFromHandle()
    {
        if (subscribedHandle is null)
        {
            return;
        }

        subscribedHandle.Unsubscribe(this);
        subscribedHandle = null;
    }

    private void SyncHandleState(bool open, string? triggerId)
    {
        Handle?.SyncState(open, triggerId, payload);
    }

    private object? GetPayloadFromHandle(string triggerId)
    {
        return Handle?.GetTriggerPayloadAsObject(triggerId);
    }

    private ElementReference? GetTriggerElementFromHandle(string triggerId)
    {
        return Handle?.GetTriggerElement(triggerId);
    }
}
