@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using BlazorBaseUI.ToggleGroup

@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<RenderElement TState="ToggleState"
               Tag="@DefaultTag"
               State="state"
               Render="Render"
               ClassValue="ClassValue"
               StyleValue="StyleValue"
               ComponentAttributes="componentAttributes"
               ChildContent="ChildContent"
               @attributes="AdditionalAttributes"
               @ref="renderElementReference" />

@code {
    private const string DefaultTag = "button";
    private const string JsModulePath = "./_content/BlazorBaseUI/blazor-baseui-toggle.js";

    private readonly Lazy<Task<IJSObjectReference>> moduleTask;

    private bool hasRendered;
    private bool isPressed;
    private bool previousPressed;
    private bool previousDisabled;
    private Orientation previousOrientation;
    private string previousResolvedValue = null!;
    private string? defaultId;
    private string resolvedValue = null!;
    private RenderElement<ToggleState>? renderElementReference;
    private ToggleState state = ToggleState.Default;
    private Dictionary<string, object> componentAttributes = new();

    private bool IsControlled => Pressed.HasValue;
    private bool IsInGroup => GroupContext is not null;

    private bool CurrentPressed
    {
        get
        {
            if (IsInGroup)
                return GroupContext!.Value.Contains(resolvedValue);

            return IsControlled ? Pressed!.Value : isPressed;
        }
    }

    private bool ResolvedDisabled => Disabled || (GroupContext?.Disabled ?? false);

    private Orientation CurrentOrientation => GroupContext?.Orientation ?? Orientation.Horizontal;

    [CascadingParameter]
    private IToggleGroupContext? GroupContext { get; set; }

    /// <summary>
    /// Gets or sets whether the toggle button is currently pressed.
    /// This is the controlled counterpart of <see cref="DefaultPressed"/>.
    /// </summary>
    [Parameter]
    public bool? Pressed { get; set; }

    /// <summary>
    /// Gets or sets whether the toggle button is initially pressed.
    /// This is the uncontrolled counterpart of <see cref="Pressed"/>.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool DefaultPressed { get; set; }

    /// <summary>
    /// Determines whether the component should ignore user interaction.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Determines whether the component renders a native <c>&lt;button&gt;</c> element
    /// when replacing it via the <see cref="Render"/> prop.
    /// Set to <see langword="false"/> if the rendered element is not a button (e.g. <c>&lt;div&gt;</c>).
    /// Defaults to <see langword="true"/>.
    /// </summary>
    [Parameter]
    public bool NativeButton { get; set; } = true;

    /// <summary>
    /// Gets or sets a unique string that identifies the toggle when used inside a <see cref="ToggleGroup.ToggleGroup"/>.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Gets or sets a callback that is invoked when the pressed state changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> PressedChanged { get; set; }

    /// <summary>
    /// Gets or sets a cancellable callback that is invoked when the pressed state changes.
    /// </summary>
    [Parameter]
    public EventCallback<TogglePressedChangeEventArgs> OnPressedChange { get; set; }

    /// <summary>
    /// Gets or sets a custom render fragment that replaces the default element.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<ToggleState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets a function that returns a CSS class based on the component's state.
    /// </summary>
    [Parameter]
    public Func<ToggleState, string>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets a function that returns an inline style based on the component's state.
    /// </summary>
    [Parameter]
    public Func<ToggleState, string>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    public Toggle()
    {
        moduleTask = new Lazy<Task<IJSObjectReference>>(() =>
            JSRuntime.InvokeAsync<IJSObjectReference>("import", JsModulePath).AsTask());
    }

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        resolvedValue = Value ?? (defaultId ??= Guid.NewGuid().ToIdString());
        previousResolvedValue = resolvedValue;

        if (!IsInGroup && !IsControlled)
        {
            isPressed = DefaultPressed;
        }

        previousPressed = CurrentPressed;
        previousDisabled = ResolvedDisabled;
        previousOrientation = CurrentOrientation;

        state = new ToggleState(CurrentPressed, ResolvedDisabled);
        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        var newValue = Value ?? defaultId!;
        if (newValue != resolvedValue)
        {
            resolvedValue = newValue;
        }

        var currentPressed = CurrentPressed;
        var resolvedDisabled = ResolvedDisabled;

        if (state.Pressed != currentPressed || state.Disabled != resolvedDisabled)
        {
            state = new ToggleState(currentPressed, resolvedDisabled);
        }

        if (hasRendered)
        {
            if (previousPressed != currentPressed)
            {
                previousPressed = currentPressed;
            }

            if (resolvedDisabled != previousDisabled)
            {
                previousDisabled = resolvedDisabled;
                _ = UpdateJsStateAsync();
            }

            if (IsInGroup && CurrentOrientation != previousOrientation)
            {
                previousOrientation = CurrentOrientation;
                _ = UpdateGroupItemOrientationAsync();
            }
        }

        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;

            if (IsInGroup && Element.HasValue)
            {
                await InitializeGroupItemAsync();
                await RegisterWithGroupAsync();
            }

            if (!NativeButton)
            {
                await InitializeJsAsync();
            }
        }
        else if (IsInGroup && Element.HasValue && resolvedValue != previousResolvedValue)
        {
            previousResolvedValue = resolvedValue;
            await RegisterWithGroupAsync();
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (moduleTask.IsValueCreated && Element.HasValue)
        {
            try
            {
                await UnregisterFromGroupAsync();
                var module = await moduleTask.Value;

                if (IsInGroup)
                {
                    await module.InvokeVoidAsync("disposeGroupItem", Element.Value);
                }

                if (!NativeButton)
                {
                    await module.InvokeVoidAsync("dispose", Element.Value);
                }

                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();
        var currentPressed = CurrentPressed;
        var resolvedDisabled = ResolvedDisabled;

        attrs["aria-pressed"] = currentPressed ? "true" : "false";

        if (NativeButton)
        {
            attrs["type"] = "button";

            if (resolvedDisabled)
            {
                attrs["disabled"] = true;
            }
            else if (IsInGroup)
            {
                var anyPressed = GroupContext!.Value.Count > 0;
                attrs["tabindex"] = currentPressed ? 0 : (!anyPressed ? 0 : -1);
            }
            else
            {
                attrs["tabindex"] = 0;
            }
        }
        else
        {
            attrs["role"] = "button";

            if (resolvedDisabled)
            {
                attrs["aria-disabled"] = "true";
                attrs["tabindex"] = -1;
            }
            else if (IsInGroup)
            {
                var anyPressed = GroupContext!.Value.Count > 0;
                attrs["tabindex"] = currentPressed ? 0 : (!anyPressed ? 0 : -1);
            }
            else
            {
                attrs["tabindex"] = 0;
            }
        }

        attrs["onclick"] = EventCallback.Factory.Create<MouseEventArgs>(this, HandleClickAsync);

        if (IsInGroup)
        {
            attrs["onkeydown"] = EventCallback.Factory.Create<KeyboardEventArgs>(this, HandleKeyDownAsync);
        }

        attrs["data-pressed"] = currentPressed;
        attrs["data-disabled"] = resolvedDisabled;

        componentAttributes = attrs;
    }

    private async Task RegisterWithGroupAsync()
    {
        if (!IsInGroup || !Element.HasValue || !GroupContext!.GroupElement.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            await module.InvokeVoidAsync("registerToggle", GroupContext.GroupElement.Value, Element.Value, resolvedValue);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task UnregisterFromGroupAsync()
    {
        if (!IsInGroup || !Element.HasValue || !GroupContext!.GroupElement.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            await module.InvokeVoidAsync("unregisterToggle", GroupContext.GroupElement.Value, Element.Value);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task InitializeJsAsync()
    {
        if (!Element.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            await module.InvokeVoidAsync("initialize", Element.Value, ResolvedDisabled);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task InitializeGroupItemAsync()
    {
        if (!Element.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            var orientationString = CurrentOrientation.ToDataAttributeString() ?? "horizontal";
            await module.InvokeVoidAsync("initializeGroupItem", Element.Value, orientationString);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task UpdateJsStateAsync()
    {
        if (!hasRendered || NativeButton || !Element.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            await module.InvokeVoidAsync("updateState", Element.Value, ResolvedDisabled);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task UpdateGroupItemOrientationAsync()
    {
        if (!hasRendered || !IsInGroup || !Element.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            var orientationString = CurrentOrientation.ToDataAttributeString() ?? "horizontal";
            await module.InvokeVoidAsync("updateGroupItemOrientation", Element.Value, orientationString);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }

    private async Task HandleClickAsync(MouseEventArgs e)
    {
        if (ResolvedDisabled)
        {
            return;
        }

        var nextPressed = !CurrentPressed;

        if (IsInGroup)
        {
            await GroupContext!.SetGroupValueAsync(resolvedValue, nextPressed);
            await EventUtilities.InvokeOnClickAsync(AdditionalAttributes, e);
            return;
        }

        var eventArgs = new TogglePressedChangeEventArgs(nextPressed);

        if (OnPressedChange.HasDelegate)
        {
            await OnPressedChange.InvokeAsync(eventArgs);

            if (eventArgs.IsCanceled)
            {
                return;
            }
        }

        if (!IsControlled)
        {
            isPressed = nextPressed;
            state = new ToggleState(isPressed, ResolvedDisabled);
        }

        if (PressedChanged.HasDelegate)
        {
            await PressedChanged.InvokeAsync(nextPressed);
        }

        await EventUtilities.InvokeOnClickAsync(AdditionalAttributes, e);
        BuildComponentAttributes();
    }

    private async Task HandleKeyDownAsync(KeyboardEventArgs e)
    {
        if (!IsInGroup || ResolvedDisabled || !GroupContext!.GroupElement.HasValue || !Element.HasValue)
        {
            return;
        }

        var orientation = GroupContext.Orientation;
        var isHorizontal = orientation == Orientation.Horizontal;
        var isVertical = orientation == Orientation.Vertical;

        var shouldNavigatePrevious =
            (isHorizontal && e.Key == "ArrowLeft") ||
            (isVertical && e.Key == "ArrowUp");

        var shouldNavigateNext =
            (isHorizontal && e.Key == "ArrowRight") ||
            (isVertical && e.Key == "ArrowDown");

        try
        {
            var module = await moduleTask.Value;
            if (shouldNavigatePrevious)
            {
                await module.InvokeVoidAsync("navigateToPrevious", GroupContext.GroupElement.Value, Element.Value);
            }
            else if (shouldNavigateNext)
            {
                await module.InvokeVoidAsync("navigateToNext", GroupContext.GroupElement.Value, Element.Value);
            }
            else if (e.Key == "Home")
            {
                await module.InvokeVoidAsync("navigateToFirst", GroupContext.GroupElement.Value);
            }
            else if (e.Key == "End")
            {
                await module.InvokeVoidAsync("navigateToLast", GroupContext.GroupElement.Value);
            }
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }

        await EventUtilities.InvokeOnKeyDownAsync(AdditionalAttributes, e);
    }
}
