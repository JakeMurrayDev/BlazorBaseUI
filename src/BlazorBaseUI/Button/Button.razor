@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop

@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject ILogger<Button> Logger

<RenderElement TState="ButtonState"
               Tag="button"
               State="state"
               Render="Render"
               ClassValue="ClassValue"
               StyleValue="StyleValue"
               ComponentAttributes="componentAttributes"
               ChildContent="ChildContent"
               @attributes="AdditionalAttributes"
               @ref="renderElementReference" />

@code {
    private readonly Lazy<Task<IJSObjectReference>> moduleTask;

    private bool hasRendered;
    private Func<bool, Task> cachedSyncJsCallback = default!;
    private bool previousDisabled;
    private bool previousFocusableWhenDisabled;
    private bool previousNativeButton;
    private ButtonState state = new(false);
    private RenderElement<ButtonState>? renderElementReference;
    private Dictionary<string, object> componentAttributes = new();

    private bool NeedsJsInterop => !NativeButton || (Disabled && FocusableWhenDisabled);

    /// <summary>
    /// Determines whether the button should ignore user interaction.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Determines whether the button may receive focus even if it is disabled.
    /// Defaults to <see langword="false"/>.
    /// </summary>
    [Parameter]
    public bool FocusableWhenDisabled { get; set; }

    /// <summary>
    /// Determines whether the component is being rendered as a native button.
    /// Defaults to <see langword="true"/>.
    /// </summary>
    [Parameter]
    public bool NativeButton { get; set; } = true;

    /// <summary>
    /// Gets or sets the tab index of the button.
    /// </summary>
    [Parameter]
    public int TabIndex { get; set; }

    /// <summary>
    /// Allows you to replace the component's HTML element
    /// with a different tag, or compose it with another component.
    /// Accepts a function that returns the element to render.
    /// </summary>
    [Parameter]
    public RenderFragment<RenderProps<ButtonState>>? Render { get; set; }

    /// <summary>
    /// Gets or sets the CSS class function based on the component state.
    /// </summary>
    [Parameter]
    public Func<ButtonState, string?>? ClassValue { get; set; }

    /// <summary>
    /// Gets or sets the inline style function based on the component state.
    /// </summary>
    [Parameter]
    public Func<ButtonState, string?>? StyleValue { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// </summary>
    public ElementReference? Element => renderElementReference?.Element;

    public Button()
    {
        moduleTask = new Lazy<Task<IJSObjectReference>>(() =>
            JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "./_content/BlazorBaseUI/blazor-baseui-button.js").AsTask());
    }

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        cachedSyncJsCallback = async (dispose) =>
        {
            try
            {
                await SyncJsAsync(dispose);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error syncing JS state in {Component}", nameof(Button));
            }
        };

        BuildComponentAttributes();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        if (state.Disabled != Disabled)
        {
            state = new ButtonState(Disabled);
        }

        BuildComponentAttributes();

        if (!hasRendered)
        {
            return;
        }

        var stateChanged = Disabled != previousDisabled ||
                           FocusableWhenDisabled != previousFocusableWhenDisabled ||
                           NativeButton != previousNativeButton;

        if (!stateChanged)
        {
            return;
        }

        var previousNeedsJs = !previousNativeButton || (previousDisabled && previousFocusableWhenDisabled);
        var currentNeedsJs = NeedsJsInterop;

        previousDisabled = Disabled;
        previousFocusableWhenDisabled = FocusableWhenDisabled;
        previousNativeButton = NativeButton;

        if (currentNeedsJs)
        {
            _ = InvokeAsync(() => cachedSyncJsCallback(false));
        }
        else if (previousNeedsJs)
        {
            _ = InvokeAsync(() => cachedSyncJsCallback(true));
        }
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            previousDisabled = Disabled;
            previousFocusableWhenDisabled = FocusableWhenDisabled;
            previousNativeButton = NativeButton;

            if (NeedsJsInterop)
            {
                await SyncJsAsync(dispose: false);
            }
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (moduleTask.IsValueCreated && Element.HasValue)
        {
            try
            {
                var module = await moduleTask.Value;
                await module.InvokeVoidAsync("sync", Element.Value, false, false, false, true);
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
            }
        }
    }

    private void BuildComponentAttributes()
    {
        var attrs = new Dictionary<string, object>();

        if (NativeButton)
        {
            attrs["type"] = "button";
            if (Disabled && FocusableWhenDisabled)
            {
                attrs["aria-disabled"] = "true";
                attrs["tabindex"] = TabIndex;
            }
            else if (Disabled)
            {
                attrs["disabled"] = true;
            }
            else
            {
                attrs["tabindex"] = TabIndex;
            }
        }
        else
        {
            attrs["role"] = "button";
            if (Disabled)
            {
                attrs["aria-disabled"] = "true";
                attrs["tabindex"] = FocusableWhenDisabled ? TabIndex : -1;
            }
            else
            {
                attrs["tabindex"] = TabIndex;
            }
        }

        attrs["data-disabled"] = Disabled;

        componentAttributes = attrs;
    }

    private async Task SyncJsAsync(bool dispose)
    {
        if (!Element.HasValue)
        {
            return;
        }

        try
        {
            var module = await moduleTask.Value;
            await module.InvokeVoidAsync("sync", Element.Value, Disabled, FocusableWhenDisabled, NativeButton, dispose);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
        {
        }
    }
}
